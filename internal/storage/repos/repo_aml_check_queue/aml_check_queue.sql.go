// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: aml_check_queue.sql

package repo_aml_check_queue

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
)

const delete = `-- name: Delete :exec
DELETE
FROM aml_check_queue
WHERE id = $1
`

func (q *Queries) Delete(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, delete, id)
	return err
}

const fetchPending = `-- name: FetchPending :many
SELECT u.id, u.email, u.email_verified_at, u.password, u.remember_token, u.processing_owner_id, u.location, u.language, u.rate_source, u.created_at, u.updated_at, u.deleted_at, u.banned, u.exchange_slug, u.rate_scale, u.dvnet_token,
       ac.id, ac.user_id, ac.service_id, ac.external_id, ac.status, ac.score, ac.risk_level, ac.created_at, ac.updated_at,
       acq.id, acq.user_id, acq.aml_check_id, acq.attempts, acq.created_at, acq.updated_at,
       amls.id, amls.slug, amls.created_at, amls.updated_at,
       acq.attempts >= $1 as is_last_attempt
FROM aml_check_queue acq
         INNER JOIN aml_checks ac ON acq.aml_check_id = ac.id AND ac.status = $2
         INNER JOIN users u on ac.user_id = u.id AND (u.banned  IS NULL OR u.banned = false)
         INNER JOIN aml_services amls ON ac.service_id = amls.id
ORDER BY acq.created_at, acq.updated_at
`

type FetchPendingRow struct {
	User          models.User          `db:"user" json:"user"`
	AmlCheck      models.AmlCheck      `db:"aml_check" json:"aml_check"`
	AmlCheckQueue models.AmlCheckQueue `db:"aml_check_queue" json:"aml_check_queue"`
	AmlService    models.AmlService    `db:"aml_service" json:"aml_service"`
	IsLastAttempt bool                 `db:"is_last_attempt" json:"is_last_attempt"`
}

func (q *Queries) FetchPending(ctx context.Context, maxQueueAttempts int32, pendingStatus models.AMLCheckStatus) ([]*FetchPendingRow, error) {
	rows, err := q.db.Query(ctx, fetchPending, maxQueueAttempts, pendingStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FetchPendingRow{}
	for rows.Next() {
		var i FetchPendingRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Email,
			&i.User.EmailVerifiedAt,
			&i.User.Password,
			&i.User.RememberToken,
			&i.User.ProcessingOwnerID,
			&i.User.Location,
			&i.User.Language,
			&i.User.RateSource,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.Banned,
			&i.User.ExchangeSlug,
			&i.User.RateScale,
			&i.User.DvnetToken,
			&i.AmlCheck.ID,
			&i.AmlCheck.UserID,
			&i.AmlCheck.ServiceID,
			&i.AmlCheck.ExternalID,
			&i.AmlCheck.Status,
			&i.AmlCheck.Score,
			&i.AmlCheck.RiskLevel,
			&i.AmlCheck.CreatedAt,
			&i.AmlCheck.UpdatedAt,
			&i.AmlCheckQueue.ID,
			&i.AmlCheckQueue.UserID,
			&i.AmlCheckQueue.AmlCheckID,
			&i.AmlCheckQueue.Attempts,
			&i.AmlCheckQueue.CreatedAt,
			&i.AmlCheckQueue.UpdatedAt,
			&i.AmlService.ID,
			&i.AmlService.Slug,
			&i.AmlService.CreatedAt,
			&i.AmlService.UpdatedAt,
			&i.IsLastAttempt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementAttempts = `-- name: IncrementAttempts :exec
UPDATE aml_check_queue SET attempts = attempts + 1 WHERE id = $1
`

func (q *Queries) IncrementAttempts(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementAttempts, id)
	return err
}
