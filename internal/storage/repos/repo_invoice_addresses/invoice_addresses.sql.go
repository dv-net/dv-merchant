// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: invoice_addresses.sql

package repo_invoice_addresses

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/constant"
	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createWithWalletAddress = `-- name: CreateWithWalletAddress :one
WITH inserted AS (
    INSERT INTO invoice_addresses (invoice_id, wallet_address_id, rate_at_creation, created_at)
        VALUES ($1, $2, $3, now())
        RETURNING id, invoice_id, wallet_address_id, rate_at_creation, created_at, updated_at
)
SELECT
    inserted.id, inserted.invoice_id, inserted.wallet_address_id, inserted.rate_at_creation, inserted.created_at, inserted.updated_at,
    wallet_addresses.id, wallet_addresses.user_id, wallet_addresses.currency_id, wallet_addresses.blockchain, wallet_addresses.address, wallet_addresses.amount, wallet_addresses.created_at, wallet_addresses.updated_at, wallet_addresses.deleted_at, wallet_addresses.dirty, wallet_addresses.status, wallet_addresses.account_type, wallet_addresses.account_id, wallet_addresses.store_id
FROM inserted
         LEFT JOIN wallet_addresses ON inserted.wallet_address_id = wallet_addresses.id
`

type CreateWithWalletAddressParams struct {
	InvoiceID       uuid.UUID           `db:"invoice_id" json:"invoice_id"`
	WalletAddressID uuid.UUID           `db:"wallet_address_id" json:"wallet_address_id"`
	RateAtCreation  decimal.NullDecimal `db:"rate_at_creation" json:"rate_at_creation"`
}

type CreateWithWalletAddressRow struct {
	ID              uuid.UUID             `db:"id" json:"id"`
	InvoiceID       uuid.UUID             `db:"invoice_id" json:"invoice_id"`
	WalletAddressID uuid.UUID             `db:"wallet_address_id" json:"wallet_address_id"`
	RateAtCreation  decimal.NullDecimal   `db:"rate_at_creation" json:"rate_at_creation"`
	CreatedAt       pgtype.Timestamptz    `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz    `db:"updated_at" json:"updated_at"`
	ID_2            uuid.NullUUID         `db:"id_2" json:"id_2"`
	UserID          uuid.NullUUID         `db:"user_id" json:"user_id"`
	CurrencyID      pgtype.Text           `db:"currency_id" json:"currency_id"`
	Blockchain      models.Blockchain     `db:"blockchain" json:"blockchain"`
	Address         pgtype.Text           `db:"address" json:"address"`
	Amount          decimal.Decimal       `db:"amount" json:"amount"`
	CreatedAt_2     pgtype.Timestamp      `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2     pgtype.Timestamp      `db:"updated_at_2" json:"updated_at_2"`
	DeletedAt       pgtype.Timestamp      `db:"deleted_at" json:"deleted_at"`
	Dirty           pgtype.Bool           `db:"dirty" json:"dirty"`
	Status          constant.WalletStatus `db:"status" json:"status"`
	AccountType     pgtype.Text           `db:"account_type" json:"account_type"`
	AccountID       uuid.NullUUID         `db:"account_id" json:"account_id"`
	StoreID         uuid.NullUUID         `db:"store_id" json:"store_id"`
}

func (q *Queries) CreateWithWalletAddress(ctx context.Context, arg CreateWithWalletAddressParams) (*CreateWithWalletAddressRow, error) {
	row := q.db.QueryRow(ctx, createWithWalletAddress, arg.InvoiceID, arg.WalletAddressID, arg.RateAtCreation)
	var i CreateWithWalletAddressRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.WalletAddressID,
		&i.RateAtCreation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.UserID,
		&i.CurrencyID,
		&i.Blockchain,
		&i.Address,
		&i.Amount,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.DeletedAt,
		&i.Dirty,
		&i.Status,
		&i.AccountType,
		&i.AccountID,
		&i.StoreID,
	)
	return &i, err
}

const getByIDWithAddress = `-- name: GetByIDWithAddress :one
SELECT invoice_addresses.id, invoice_id, wallet_address_id, rate_at_creation, invoice_addresses.created_at, invoice_addresses.updated_at, wallet_addresses.id, user_id, currency_id, blockchain, address, amount, wallet_addresses.created_at, wallet_addresses.updated_at, deleted_at, dirty, status, account_type, account_id, store_id
FROM invoice_addresses
         LEFT JOIN wallet_addresses ON invoice_addresses.wallet_address_id = wallet_addresses.id
WHERE invoice_addresses.id = $1 LIMIT 1
`

type GetByIDWithAddressRow struct {
	ID              uuid.UUID             `db:"id" json:"id"`
	InvoiceID       uuid.UUID             `db:"invoice_id" json:"invoice_id"`
	WalletAddressID uuid.UUID             `db:"wallet_address_id" json:"wallet_address_id"`
	RateAtCreation  decimal.NullDecimal   `db:"rate_at_creation" json:"rate_at_creation"`
	CreatedAt       pgtype.Timestamptz    `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz    `db:"updated_at" json:"updated_at"`
	ID_2            uuid.NullUUID         `db:"id_2" json:"id_2"`
	UserID          uuid.NullUUID         `db:"user_id" json:"user_id"`
	CurrencyID      pgtype.Text           `db:"currency_id" json:"currency_id"`
	Blockchain      models.Blockchain     `db:"blockchain" json:"blockchain"`
	Address         pgtype.Text           `db:"address" json:"address"`
	Amount          decimal.Decimal       `db:"amount" json:"amount"`
	CreatedAt_2     pgtype.Timestamp      `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2     pgtype.Timestamp      `db:"updated_at_2" json:"updated_at_2"`
	DeletedAt       pgtype.Timestamp      `db:"deleted_at" json:"deleted_at"`
	Dirty           pgtype.Bool           `db:"dirty" json:"dirty"`
	Status          constant.WalletStatus `db:"status" json:"status"`
	AccountType     pgtype.Text           `db:"account_type" json:"account_type"`
	AccountID       uuid.NullUUID         `db:"account_id" json:"account_id"`
	StoreID         uuid.NullUUID         `db:"store_id" json:"store_id"`
}

func (q *Queries) GetByIDWithAddress(ctx context.Context, id uuid.UUID) (*GetByIDWithAddressRow, error) {
	row := q.db.QueryRow(ctx, getByIDWithAddress, id)
	var i GetByIDWithAddressRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.WalletAddressID,
		&i.RateAtCreation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.UserID,
		&i.CurrencyID,
		&i.Blockchain,
		&i.Address,
		&i.Amount,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.DeletedAt,
		&i.Dirty,
		&i.Status,
		&i.AccountType,
		&i.AccountID,
		&i.StoreID,
	)
	return &i, err
}

const getByInvoiceID = `-- name: GetByInvoiceID :many
SELECT invoice_addresses.id, invoice_id, wallet_address_id, rate_at_creation, invoice_addresses.created_at, invoice_addresses.updated_at, wallet_addresses.id, user_id, currency_id, blockchain, address, amount, wallet_addresses.created_at, wallet_addresses.updated_at, deleted_at, dirty, status, account_type, account_id, store_id
FROM invoice_addresses
         LEFT JOIN wallet_addresses ON invoice_addresses.wallet_address_id = wallet_addresses.id
WHERE invoice_id = $1
`

type GetByInvoiceIDRow struct {
	ID              uuid.UUID             `db:"id" json:"id"`
	InvoiceID       uuid.UUID             `db:"invoice_id" json:"invoice_id"`
	WalletAddressID uuid.UUID             `db:"wallet_address_id" json:"wallet_address_id"`
	RateAtCreation  decimal.NullDecimal   `db:"rate_at_creation" json:"rate_at_creation"`
	CreatedAt       pgtype.Timestamptz    `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz    `db:"updated_at" json:"updated_at"`
	ID_2            uuid.NullUUID         `db:"id_2" json:"id_2"`
	UserID          uuid.NullUUID         `db:"user_id" json:"user_id"`
	CurrencyID      pgtype.Text           `db:"currency_id" json:"currency_id"`
	Blockchain      models.Blockchain     `db:"blockchain" json:"blockchain"`
	Address         pgtype.Text           `db:"address" json:"address"`
	Amount          decimal.Decimal       `db:"amount" json:"amount"`
	CreatedAt_2     pgtype.Timestamp      `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2     pgtype.Timestamp      `db:"updated_at_2" json:"updated_at_2"`
	DeletedAt       pgtype.Timestamp      `db:"deleted_at" json:"deleted_at"`
	Dirty           pgtype.Bool           `db:"dirty" json:"dirty"`
	Status          constant.WalletStatus `db:"status" json:"status"`
	AccountType     pgtype.Text           `db:"account_type" json:"account_type"`
	AccountID       uuid.NullUUID         `db:"account_id" json:"account_id"`
	StoreID         uuid.NullUUID         `db:"store_id" json:"store_id"`
}

func (q *Queries) GetByInvoiceID(ctx context.Context, invoiceID uuid.UUID) ([]*GetByInvoiceIDRow, error) {
	rows, err := q.db.Query(ctx, getByInvoiceID, invoiceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetByInvoiceIDRow{}
	for rows.Next() {
		var i GetByInvoiceIDRow
		if err := rows.Scan(
			&i.ID,
			&i.InvoiceID,
			&i.WalletAddressID,
			&i.RateAtCreation,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.UserID,
			&i.CurrencyID,
			&i.Blockchain,
			&i.Address,
			&i.Amount,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt,
			&i.Dirty,
			&i.Status,
			&i.AccountType,
			&i.AccountID,
			&i.StoreID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByWalletAddressID = `-- name: GetByWalletAddressID :one
SELECT invoice_addresses.id, invoice_id, wallet_address_id, rate_at_creation, invoice_addresses.created_at, invoice_addresses.updated_at, invoices.id, user_id, store_id, order_id, expected_amount_usd, received_amount_usd, status, expires_at, invoices.created_at, invoices.updated_at
FROM invoice_addresses
         LEFT JOIN invoices ON invoice_addresses.invoice_id = invoices.id
WHERE invoice_addresses.wallet_address_id = $1 ORDER BY invoices.created_at DESC LIMIT 1
`

type GetByWalletAddressIDRow struct {
	ID                uuid.UUID              `db:"id" json:"id"`
	InvoiceID         uuid.UUID              `db:"invoice_id" json:"invoice_id"`
	WalletAddressID   uuid.UUID              `db:"wallet_address_id" json:"wallet_address_id"`
	RateAtCreation    decimal.NullDecimal    `db:"rate_at_creation" json:"rate_at_creation"`
	CreatedAt         pgtype.Timestamptz     `db:"created_at" json:"created_at"`
	UpdatedAt         pgtype.Timestamptz     `db:"updated_at" json:"updated_at"`
	ID_2              uuid.NullUUID          `db:"id_2" json:"id_2"`
	UserID            uuid.NullUUID          `db:"user_id" json:"user_id"`
	StoreID           uuid.NullUUID          `db:"store_id" json:"store_id"`
	OrderID           pgtype.Text            `db:"order_id" json:"order_id"`
	ExpectedAmountUsd decimal.NullDecimal    `db:"expected_amount_usd" json:"expected_amount_usd"`
	ReceivedAmountUsd decimal.NullDecimal    `db:"received_amount_usd" json:"received_amount_usd"`
	Status            constant.InvoiceStatus `db:"status" json:"status"`
	ExpiresAt         pgtype.Timestamptz     `db:"expires_at" json:"expires_at"`
	CreatedAt_2       pgtype.Timestamptz     `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2       pgtype.Timestamptz     `db:"updated_at_2" json:"updated_at_2"`
}

func (q *Queries) GetByWalletAddressID(ctx context.Context, walletAddressID uuid.UUID) (*GetByWalletAddressIDRow, error) {
	row := q.db.QueryRow(ctx, getByWalletAddressID, walletAddressID)
	var i GetByWalletAddressIDRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.WalletAddressID,
		&i.RateAtCreation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.UserID,
		&i.StoreID,
		&i.OrderID,
		&i.ExpectedAmountUsd,
		&i.ReceivedAmountUsd,
		&i.Status,
		&i.ExpiresAt,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
	)
	return &i, err
}

const getInvoiceAddressByInvoiceAndCurrency = `-- name: GetInvoiceAddressByInvoiceAndCurrency :one
SELECT invoice_addresses.id, invoice_id, wallet_address_id, rate_at_creation, invoice_addresses.created_at, invoice_addresses.updated_at, wallet_addresses.id, user_id, currency_id, blockchain, address, amount, wallet_addresses.created_at, wallet_addresses.updated_at, deleted_at, dirty, status, account_type, account_id, store_id
FROM invoice_addresses
         LEFT JOIN wallet_addresses ON invoice_addresses.wallet_address_id = wallet_addresses.id
WHERE invoice_id = $1 AND wallet_addresses.currency_id = $2 LIMIT 1
`

type GetInvoiceAddressByInvoiceAndCurrencyParams struct {
	InvoiceID  uuid.UUID `db:"invoice_id" json:"invoice_id"`
	CurrencyID string    `db:"currency_id" json:"currency_id"`
}

type GetInvoiceAddressByInvoiceAndCurrencyRow struct {
	ID              uuid.UUID             `db:"id" json:"id"`
	InvoiceID       uuid.UUID             `db:"invoice_id" json:"invoice_id"`
	WalletAddressID uuid.UUID             `db:"wallet_address_id" json:"wallet_address_id"`
	RateAtCreation  decimal.NullDecimal   `db:"rate_at_creation" json:"rate_at_creation"`
	CreatedAt       pgtype.Timestamptz    `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz    `db:"updated_at" json:"updated_at"`
	ID_2            uuid.NullUUID         `db:"id_2" json:"id_2"`
	UserID          uuid.NullUUID         `db:"user_id" json:"user_id"`
	CurrencyID      pgtype.Text           `db:"currency_id" json:"currency_id"`
	Blockchain      models.Blockchain     `db:"blockchain" json:"blockchain"`
	Address         pgtype.Text           `db:"address" json:"address"`
	Amount          decimal.Decimal       `db:"amount" json:"amount"`
	CreatedAt_2     pgtype.Timestamp      `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2     pgtype.Timestamp      `db:"updated_at_2" json:"updated_at_2"`
	DeletedAt       pgtype.Timestamp      `db:"deleted_at" json:"deleted_at"`
	Dirty           pgtype.Bool           `db:"dirty" json:"dirty"`
	Status          constant.WalletStatus `db:"status" json:"status"`
	AccountType     pgtype.Text           `db:"account_type" json:"account_type"`
	AccountID       uuid.NullUUID         `db:"account_id" json:"account_id"`
	StoreID         uuid.NullUUID         `db:"store_id" json:"store_id"`
}

func (q *Queries) GetInvoiceAddressByInvoiceAndCurrency(ctx context.Context, arg GetInvoiceAddressByInvoiceAndCurrencyParams) (*GetInvoiceAddressByInvoiceAndCurrencyRow, error) {
	row := q.db.QueryRow(ctx, getInvoiceAddressByInvoiceAndCurrency, arg.InvoiceID, arg.CurrencyID)
	var i GetInvoiceAddressByInvoiceAndCurrencyRow
	err := row.Scan(
		&i.ID,
		&i.InvoiceID,
		&i.WalletAddressID,
		&i.RateAtCreation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ID_2,
		&i.UserID,
		&i.CurrencyID,
		&i.Blockchain,
		&i.Address,
		&i.Amount,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.DeletedAt,
		&i.Dirty,
		&i.Status,
		&i.AccountType,
		&i.AccountID,
		&i.StoreID,
	)
	return &i, err
}
