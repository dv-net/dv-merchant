// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: multi_withdrawal_rules.sql

package repo_multi_withdrawal_rules

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrUpdate = `-- name: CreateOrUpdate :exec
INSERT INTO multi_withdrawal_rules (withdrawal_wallet_id, mode, manual_address, created_at, updated_at)
VALUES ($1, $2, $3, now(), now())
ON CONFLICT (withdrawal_wallet_id) DO UPDATE SET mode           = $2,
                                                 manual_address = $3,
                                                 updated_at     = now()
`

type CreateOrUpdateParams struct {
	WithdrawalWalletID uuid.UUID                  `db:"withdrawal_wallet_id" json:"withdrawal_wallet_id"`
	Mode               models.MultiWithdrawalMode `db:"mode" json:"mode"`
	ManualAddress      pgtype.Text                `db:"manual_address" json:"manual_address"`
}

func (q *Queries) CreateOrUpdate(ctx context.Context, arg CreateOrUpdateParams) error {
	_, err := q.db.Exec(ctx, createOrUpdate, arg.WithdrawalWalletID, arg.Mode, arg.ManualAddress)
	return err
}

const getByWalletID = `-- name: GetByWalletID :one
SELECT id, withdrawal_wallet_id, mode, manual_address, created_at, updated_at
FROM multi_withdrawal_rules
WHERE withdrawal_wallet_id = $1
LIMIT 1
`

func (q *Queries) GetByWalletID(ctx context.Context, withdrawalWalletID uuid.UUID) (*models.MultiWithdrawalRule, error) {
	row := q.db.QueryRow(ctx, getByWalletID, withdrawalWalletID)
	var i models.MultiWithdrawalRule
	err := row.Scan(
		&i.ID,
		&i.WithdrawalWalletID,
		&i.Mode,
		&i.ManualAddress,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const removeByWalletID = `-- name: RemoveByWalletID :exec
DELETE
FROM multi_withdrawal_rules
WHERE withdrawal_wallet_id = $1
`

func (q *Queries) RemoveByWalletID(ctx context.Context, withdrawalWalletID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeByWalletID, withdrawalWalletID)
	return err
}
