// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: exchanges.sql

package repo_exchanges

import (
	"context"
	"github.com/dv-net/dv-merchant/internal/models"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAllActiveWithUserKeys = `-- name: GetAllActiveWithUserKeys :many
SELECT e.slug, e.name, euk.value, ek.name as key_name, ek.title as key_title, euk.created_at as exchange_connected_at FROM exchanges e
         LEFT JOIN exchange_keys ek on e.id = ek.exchange_id
         LEFT JOIN exchange_user_keys euk on ek.id = euk.exchange_key_id AND euk.user_id = $1
         WHERE is_active=true
`

type GetAllActiveWithUserKeysRow struct {
	Slug                models.ExchangeSlug    `db:"slug" json:"slug"`
	Name                string                 `db:"name" json:"name"`
	Value               pgtype.Text            `db:"value" json:"value"`
	KeyName             models.ExchangeKeyName `db:"key_name" json:"key_name"`
	KeyTitle            pgtype.Text            `db:"key_title" json:"key_title"`
	ExchangeConnectedAt pgtype.Timestamp       `db:"exchange_connected_at" json:"exchange_connected_at"`
}

func (q *Queries) GetAllActiveWithUserKeys(ctx context.Context, userID uuid.UUID) ([]*GetAllActiveWithUserKeysRow, error) {
	rows, err := q.db.Query(ctx, getAllActiveWithUserKeys, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllActiveWithUserKeysRow{}
	for rows.Next() {
		var i GetAllActiveWithUserKeysRow
		if err := rows.Scan(
			&i.Slug,
			&i.Name,
			&i.Value,
			&i.KeyName,
			&i.KeyTitle,
			&i.ExchangeConnectedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExchangeBySlug = `-- name: GetExchangeBySlug :one
SELECT id, slug, name, is_active, url, created_at, updated_at FROM exchanges WHERE slug = $1
`

func (q *Queries) GetExchangeBySlug(ctx context.Context, slug models.ExchangeSlug) (*models.Exchange, error) {
	row := q.db.QueryRow(ctx, getExchangeBySlug, slug)
	var i models.Exchange
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.IsActive,
		&i.Url,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getExchangeKeysBySlug = `-- name: GetExchangeKeysBySlug :many
SELECT ek.name, euk.id as user_key_id, ek.id as exchange_key_id, euk.value as existing_key_value
FROM exchanges e
         INNER JOIN exchange_keys ek ON e.id = ek.exchange_id
         LEFT JOIN exchange_user_keys euk ON euk.exchange_key_id = ek.id AND euk.user_id = $1
WHERE e.slug = $2
`

type GetExchangeKeysBySlugParams struct {
	UserID uuid.UUID           `db:"user_id" json:"user_id"`
	Slug   models.ExchangeSlug `db:"slug" json:"slug"`
}

type GetExchangeKeysBySlugRow struct {
	Name             models.ExchangeKeyName `db:"name" json:"name"`
	UserKeyID        uuid.NullUUID          `db:"user_key_id" json:"user_key_id"`
	ExchangeKeyID    uuid.UUID              `db:"exchange_key_id" json:"exchange_key_id"`
	ExistingKeyValue pgtype.Text            `db:"existing_key_value" json:"existing_key_value"`
}

func (q *Queries) GetExchangeKeysBySlug(ctx context.Context, arg GetExchangeKeysBySlugParams) ([]*GetExchangeKeysBySlugRow, error) {
	rows, err := q.db.Query(ctx, getExchangeKeysBySlug, arg.UserID, arg.Slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetExchangeKeysBySlugRow{}
	for rows.Next() {
		var i GetExchangeKeysBySlugRow
		if err := rows.Scan(
			&i.Name,
			&i.UserKeyID,
			&i.ExchangeKeyID,
			&i.ExistingKeyValue,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
