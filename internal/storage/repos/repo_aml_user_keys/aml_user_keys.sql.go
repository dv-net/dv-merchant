// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: aml_user_keys.sql

package repo_aml_user_keys

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOrUpdateUserKeys = `-- name: CreateOrUpdateUserKeys :one
INSERT INTO aml_user_keys (user_id, key_id, value, created_at)
VALUES ($1, $2, $3, now())
ON CONFLICT (user_id, key_id) DO UPDATE
    SET value      = $3,
        updated_at = now()
RETURNING id, key_id, user_id, value, created_at, updated_at
`

func (q *Queries) CreateOrUpdateUserKeys(ctx context.Context, userID uuid.UUID, keyID uuid.UUID, value string) (*models.AmlUserKey, error) {
	row := q.db.QueryRow(ctx, createOrUpdateUserKeys, userID, keyID, value)
	var i models.AmlUserKey
	err := row.Scan(
		&i.ID,
		&i.KeyID,
		&i.UserID,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createUserKeys = `-- name: CreateUserKeys :exec
INSERT INTO aml_user_keys (key_id, user_id, value, created_at)
VALUES ($1, $2, $3, now())
ON CONFLICT (user_id, key_id) DO UPDATE set value      = $3,
                                            updated_at = now()
`

func (q *Queries) CreateUserKeys(ctx context.Context, keyID uuid.UUID, userID uuid.UUID, value string) error {
	_, err := q.db.Exec(ctx, createUserKeys, keyID, userID, value)
	return err
}

const deleteAllUserKeysBySlug = `-- name: DeleteAllUserKeysBySlug :exec
DELETE
FROM aml_user_keys auk
    USING aml_service_keys ask
        JOIN aml_services s ON ask.service_id = s.id
WHERE auk.user_id = $1
  AND auk.key_id = ask.id
  AND s.slug = $2
`

func (q *Queries) DeleteAllUserKeysBySlug(ctx context.Context, userID uuid.UUID, slug models.AMLSlug) error {
	_, err := q.db.Exec(ctx, deleteAllUserKeysBySlug, userID, slug)
	return err
}

const deleteAllUserKeysBySlugAndKeyID = `-- name: DeleteAllUserKeysBySlugAndKeyID :exec
DELETE FROM aml_user_keys auk
    USING aml_service_keys ask
        JOIN aml_services s ON ask.service_id = s.id
WHERE auk.user_id = $1
  AND auk.key_id = ask.id
  AND s.slug = $2
  AND ask.id = $3
`

func (q *Queries) DeleteAllUserKeysBySlugAndKeyID(ctx context.Context, userID uuid.UUID, slug models.AMLSlug, iD uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllUserKeysBySlugAndKeyID, userID, slug, iD)
	return err
}

const fetchAllBySlug = `-- name: FetchAllBySlug :many
SELECT ask.id, ask.name, ask.description, auk.value
FROM aml_service_keys ask
         LEFT JOIN aml_user_keys auk ON ask.id = auk.key_id AND auk.user_id = $1
         INNER JOIN aml_services amls ON ask.service_id = amls.id
WHERE amls.slug = $2
`

type FetchAllBySlugRow struct {
	ID          uuid.UUID         `db:"id" json:"id"`
	Name        models.AmlKeyType `db:"name" json:"name"`
	Description string            `db:"description" json:"description"`
	Value       pgtype.Text       `db:"value" json:"value"`
}

func (q *Queries) FetchAllBySlug(ctx context.Context, userID uuid.UUID, slug models.AMLSlug) ([]*FetchAllBySlugRow, error) {
	rows, err := q.db.Query(ctx, fetchAllBySlug, userID, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FetchAllBySlugRow{}
	for rows.Next() {
		var i FetchAllBySlugRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchServiceKeyIDBySlugAndName = `-- name: FetchServiceKeyIDBySlugAndName :one
SELECT ask.id
FROM aml_service_keys ask
         JOIN aml_services s ON ask.service_id = s.id
WHERE s.slug = $1 AND ask.name = $2
`

func (q *Queries) FetchServiceKeyIDBySlugAndName(ctx context.Context, slug models.AMLSlug, name models.AmlKeyType) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, fetchServiceKeyIDBySlugAndName, slug, name)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const prepareServiceDataByUserAndSlug = `-- name: PrepareServiceDataByUserAndSlug :many
SElECT ams.id, ams.slug, ams.created_at, ams.updated_at, ask.name, auk.value
FROM aml_user_keys auk
         INNER JOIN aml_service_keys ask ON auk.key_id = ask.id
         INNER JOIN aml_services ams ON ask.service_id = ams.id AND ams.slug = $1
WHERE auk.user_id = $2
`

type PrepareServiceDataByUserAndSlugRow struct {
	AmlService models.AmlService `db:"aml_service" json:"aml_service"`
	Name       models.AmlKeyType `db:"name" json:"name"`
	Value      string            `db:"value" json:"value"`
}

func (q *Queries) PrepareServiceDataByUserAndSlug(ctx context.Context, slug models.AMLSlug, userID uuid.UUID) ([]*PrepareServiceDataByUserAndSlugRow, error) {
	rows, err := q.db.Query(ctx, prepareServiceDataByUserAndSlug, slug, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*PrepareServiceDataByUserAndSlugRow{}
	for rows.Next() {
		var i PrepareServiceDataByUserAndSlugRow
		if err := rows.Scan(
			&i.AmlService.ID,
			&i.AmlService.Slug,
			&i.AmlService.CreatedAt,
			&i.AmlService.UpdatedAt,
			&i.Name,
			&i.Value,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
