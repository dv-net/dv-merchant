// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: store_api_keys.sql

package repo_store_api_keys

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
)

const disableByStore = `-- name: DisableByStore :exec
UPDATE store_api_keys SET enabled=false, updated_at = now() WHERE store_id = $1
`

func (q *Queries) DisableByStore(ctx context.Context, storeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, disableByStore, storeID)
	return err
}

const enableByStore = `-- name: EnableByStore :exec
UPDATE store_api_keys SET enabled=true, updated_at = now() WHERE store_id = $1
`

func (q *Queries) EnableByStore(ctx context.Context, storeID uuid.UUID) error {
	_, err := q.db.Exec(ctx, enableByStore, storeID)
	return err
}

const getByStoreId = `-- name: GetByStoreId :many
SELECT id, store_id, key, enabled, created_at, updated_at
FROM store_api_keys
WHERE store_id =$1
ORDER BY created_at
`

func (q *Queries) GetByStoreId(ctx context.Context, storeID uuid.UUID) ([]*models.StoreApiKey, error) {
	rows, err := q.db.Query(ctx, getByStoreId, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.StoreApiKey{}
	for rows.Next() {
		var i models.StoreApiKey
		if err := rows.Scan(
			&i.ID,
			&i.StoreID,
			&i.Key,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoreByKey = `-- name: GetStoreByKey :one
SELECT s.id, s.user_id, s.name, s.site, s.currency_id, s.rate_source, s.return_url, s.success_url, s.rate_scale, s.status, s.minimal_payment, s.created_at, s.updated_at, s.deleted_at, s.public_payment_form_enabled
FROM store_api_keys sak
         INNER JOIN stores s on s.id = sak.store_id
WHERE sak.key = $1 and sak.enabled = true
LIMIT 1
`

func (q *Queries) GetStoreByKey(ctx context.Context, key string) (*models.Store, error) {
	row := q.db.QueryRow(ctx, getStoreByKey, key)
	var i models.Store
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Site,
		&i.CurrencyID,
		&i.RateSource,
		&i.ReturnUrl,
		&i.SuccessUrl,
		&i.RateScale,
		&i.Status,
		&i.MinimalPayment,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PublicPaymentFormEnabled,
	)
	return &i, err
}

const updateKey = `-- name: UpdateKey :one
UPDATE store_api_keys
SET key=$1, updated_at=now()
WHERE store_id=$2
    RETURNING id, store_id, key, enabled, created_at, updated_at
`

type UpdateKeyParams struct {
	Key     string    `db:"key" json:"key"`
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
}

func (q *Queries) UpdateKey(ctx context.Context, arg UpdateKeyParams) (*models.StoreApiKey, error) {
	row := q.db.QueryRow(ctx, updateKey, arg.Key, arg.StoreID)
	var i models.StoreApiKey
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.Key,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
