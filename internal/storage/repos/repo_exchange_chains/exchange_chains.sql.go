// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: exchange_chains.sql

package repo_exchange_chains

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAll = `-- name: GetAll :many
SELECT e.slug, e.currency_id, e.ticker, e.chain FROM exchange_chains e
`

type GetAllRow struct {
	Slug       models.ExchangeSlug `db:"slug" json:"slug"`
	CurrencyID string              `db:"currency_id" json:"currency_id"`
	Ticker     string              `db:"ticker" json:"ticker"`
	Chain      string              `db:"chain" json:"chain"`
}

func (q *Queries) GetAll(ctx context.Context) ([]*GetAllRow, error) {
	rows, err := q.db.Query(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllRow{}
	for rows.Next() {
		var i GetAllRow
		if err := rows.Scan(
			&i.Slug,
			&i.CurrencyID,
			&i.Ticker,
			&i.Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrencyIDByParams = `-- name: GetCurrencyIDByParams :one
SELECT ec.currency_id FROM exchange_chains ec
    WHERE slug = $1 AND chain = $2 AND ec.ticker = $3
`

type GetCurrencyIDByParamsParams struct {
	Slug   models.ExchangeSlug `db:"slug" json:"slug"`
	Chain  string              `db:"chain" json:"chain"`
	Ticker string              `db:"ticker" json:"ticker"`
}

func (q *Queries) GetCurrencyIDByParams(ctx context.Context, arg GetCurrencyIDByParamsParams) (string, error) {
	row := q.db.QueryRow(ctx, getCurrencyIDByParams, arg.Slug, arg.Chain, arg.Ticker)
	var currency_id string
	err := row.Scan(&currency_id)
	return currency_id, err
}

const getCurrencyIDBySlugAndChain = `-- name: GetCurrencyIDBySlugAndChain :one
SELECT ec.currency_id FROM exchange_chains ec
    WHERE slug = $1 AND chain = $2
`

type GetCurrencyIDBySlugAndChainParams struct {
	Slug  models.ExchangeSlug `db:"slug" json:"slug"`
	Chain string              `db:"chain" json:"chain"`
}

func (q *Queries) GetCurrencyIDBySlugAndChain(ctx context.Context, arg GetCurrencyIDBySlugAndChainParams) (string, error) {
	row := q.db.QueryRow(ctx, getCurrencyIDBySlugAndChain, arg.Slug, arg.Chain)
	var currency_id string
	err := row.Scan(&currency_id)
	return currency_id, err
}

const getCurrencyIDByTicker = `-- name: GetCurrencyIDByTicker :one
SELECT currency_id FROM exchange_chains WHERE ticker = $1
`

func (q *Queries) GetCurrencyIDByTicker(ctx context.Context, ticker string) (string, error) {
	row := q.db.QueryRow(ctx, getCurrencyIDByTicker, ticker)
	var currency_id string
	err := row.Scan(&currency_id)
	return currency_id, err
}

const getEnabledCurrencies = `-- name: GetEnabledCurrencies :many
SELECT c.id, c.code, c.name, c.blockchain, ec.ticker, chain FROM exchange_chains ec
    LEFT JOIN currencies c on ec.currency_id = c.id
    WHERE slug = $1 AND c.status IS true
`

type GetEnabledCurrenciesRow struct {
	ID         pgtype.Text        `db:"id" json:"id"`
	Code       pgtype.Text        `db:"code" json:"code"`
	Name       pgtype.Text        `db:"name" json:"name"`
	Blockchain *models.Blockchain `db:"blockchain" json:"blockchain"`
	Ticker     string             `db:"ticker" json:"ticker"`
	Chain      string             `db:"chain" json:"chain"`
}

func (q *Queries) GetEnabledCurrencies(ctx context.Context, slug models.ExchangeSlug) ([]*GetEnabledCurrenciesRow, error) {
	rows, err := q.db.Query(ctx, getEnabledCurrencies, slug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEnabledCurrenciesRow{}
	for rows.Next() {
		var i GetEnabledCurrenciesRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Blockchain,
			&i.Ticker,
			&i.Chain,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTickerByCurrencyID = `-- name: GetTickerByCurrencyID :one
SELECT ticker FROM exchange_chains WHERE currency_id = $1 AND slug = $2
`

type GetTickerByCurrencyIDParams struct {
	CurrencyID string              `db:"currency_id" json:"currency_id"`
	Slug       models.ExchangeSlug `db:"slug" json:"slug"`
}

func (q *Queries) GetTickerByCurrencyID(ctx context.Context, arg GetTickerByCurrencyIDParams) (string, error) {
	row := q.db.QueryRow(ctx, getTickerByCurrencyID, arg.CurrencyID, arg.Slug)
	var ticker string
	err := row.Scan(&ticker)
	return ticker, err
}
