// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: withdrawal_wallets.sql

package repo_withdrawal_wallets

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const getForMultiWithdrawal = `-- name: GetForMultiWithdrawal :many
SELECT u.id, u.email, u.email_verified_at, u.password, u.remember_token, u.processing_owner_id, u.location, u.language, u.rate_source, u.created_at, u.updated_at, u.deleted_at, u.banned, u.exchange_slug, u.rate_scale, u.dvnet_token,
       mwr.id, mwr.withdrawal_wallet_id, mwr.mode, mwr.manual_address, mwr.created_at, mwr.updated_at,
       curr.id, curr.code, curr.name, curr.precision, curr.is_fiat, curr.blockchain, curr.contract_address, curr.withdrawal_min_balance, curr.has_balance, curr.status, curr.sort_order, curr.min_confirmation, curr.created_at, curr.updated_at, curr.is_stablecoin, curr.currency_label, curr.token_label,
       ww.id, ww.user_id, ww.blockchain, ww.currency_id, ww.withdrawal_min_balance, ww.withdrawal_interval, ww.created_at, ww.deleted_at, ww.updated_at, ww.withdrawal_enabled, ww.withdrawal_min_balance_usd,
       array_agg(wwa.address) FILTER (WHERE wwa.address IS NOT NULL)::varchar[] AS addresses
FROM withdrawal_wallets ww
         INNER JOIN multi_withdrawal_rules mwr
                    ON ww.id = mwr.withdrawal_wallet_id
                        AND mwr.mode != 'disabled'
         INNER JOIN users u
                    ON ww.user_id = u.id
                        AND (u.banned = false OR u.banned IS NULL)
         INNER JOIN currencies curr
                    ON ww.currency_id = curr.id
         LEFT JOIN withdrawal_wallet_addresses wwa
                   ON ww.id = wwa.withdrawal_wallet_id AND wwa.deleted_at IS NULL
WHERE ww.blockchain = ANY (ARRAY ['bitcoin', 'litecoin', 'bitcoincash', 'dogecoin']::varchar[])
  AND ($1::uuid IS NULL OR u.id = $1::uuid)
GROUP BY u.id, curr.id, mwr.id, ww.id
`

type GetForMultiWithdrawalRow struct {
	User                models.User                `db:"user" json:"user"`
	MultiWithdrawalRule models.MultiWithdrawalRule `db:"multi_withdrawal_rule" json:"multi_withdrawal_rule"`
	Currency            models.Currency            `db:"currency" json:"currency"`
	WithdrawalWallet    models.WithdrawalWallet    `db:"withdrawal_wallet" json:"withdrawal_wallet"`
	Addresses           []string                   `db:"addresses" json:"addresses"`
}

func (q *Queries) GetForMultiWithdrawal(ctx context.Context, userID uuid.NullUUID) ([]*GetForMultiWithdrawalRow, error) {
	rows, err := q.db.Query(ctx, getForMultiWithdrawal, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetForMultiWithdrawalRow{}
	for rows.Next() {
		var i GetForMultiWithdrawalRow
		if err := rows.Scan(
			&i.User.ID,
			&i.User.Email,
			&i.User.EmailVerifiedAt,
			&i.User.Password,
			&i.User.RememberToken,
			&i.User.ProcessingOwnerID,
			&i.User.Location,
			&i.User.Language,
			&i.User.RateSource,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.Banned,
			&i.User.ExchangeSlug,
			&i.User.RateScale,
			&i.User.DvnetToken,
			&i.MultiWithdrawalRule.ID,
			&i.MultiWithdrawalRule.WithdrawalWalletID,
			&i.MultiWithdrawalRule.Mode,
			&i.MultiWithdrawalRule.ManualAddress,
			&i.MultiWithdrawalRule.CreatedAt,
			&i.MultiWithdrawalRule.UpdatedAt,
			&i.Currency.ID,
			&i.Currency.Code,
			&i.Currency.Name,
			&i.Currency.Precision,
			&i.Currency.IsFiat,
			&i.Currency.Blockchain,
			&i.Currency.ContractAddress,
			&i.Currency.WithdrawalMinBalance,
			&i.Currency.HasBalance,
			&i.Currency.Status,
			&i.Currency.SortOrder,
			&i.Currency.MinConfirmation,
			&i.Currency.CreatedAt,
			&i.Currency.UpdatedAt,
			&i.Currency.IsStablecoin,
			&i.Currency.CurrencyLabel,
			&i.Currency.TokenLabel,
			&i.WithdrawalWallet.ID,
			&i.WithdrawalWallet.UserID,
			&i.WithdrawalWallet.Blockchain,
			&i.WithdrawalWallet.CurrencyID,
			&i.WithdrawalWallet.WithdrawalMinBalance,
			&i.WithdrawalWallet.WithdrawalInterval,
			&i.WithdrawalWallet.CreatedAt,
			&i.WithdrawalWallet.DeletedAt,
			&i.WithdrawalWallet.UpdatedAt,
			&i.WithdrawalWallet.WithdrawalEnabled,
			&i.WithdrawalWallet.WithdrawalMinBalanceUsd,
			&i.Addresses,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletsForWithdrawal = `-- name: GetWalletsForWithdrawal :many
SELECT id, user_id, blockchain, currency_id, withdrawal_min_balance, withdrawal_interval, created_at, deleted_at, updated_at, withdrawal_enabled, withdrawal_min_balance_usd
FROM withdrawal_wallets
WHERE blockchain = $1
  and withdrawal_enabled = 'enabled'
`

func (q *Queries) GetWalletsForWithdrawal(ctx context.Context, blockchain models.Blockchain) ([]*models.WithdrawalWallet, error) {
	rows, err := q.db.Query(ctx, getWalletsForWithdrawal, blockchain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.WithdrawalWallet{}
	for rows.Next() {
		var i models.WithdrawalWallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Blockchain,
			&i.CurrencyID,
			&i.WithdrawalMinBalance,
			&i.WithdrawalInterval,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.UpdatedAt,
			&i.WithdrawalEnabled,
			&i.WithdrawalMinBalanceUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWithdrawalWalletByCurrency = `-- name: GetWithdrawalWalletByCurrency :one
SELECT id, user_id, blockchain, currency_id, withdrawal_min_balance, withdrawal_interval, created_at, deleted_at, updated_at, withdrawal_enabled, withdrawal_min_balance_usd
FROM withdrawal_wallets
WHERE withdrawal_wallets.user_id = $1
  AND currency_id = $2
`

type GetWithdrawalWalletByCurrencyParams struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	CurrencyID string    `db:"currency_id" json:"currency_id"`
}

func (q *Queries) GetWithdrawalWalletByCurrency(ctx context.Context, arg GetWithdrawalWalletByCurrencyParams) (*models.WithdrawalWallet, error) {
	row := q.db.QueryRow(ctx, getWithdrawalWalletByCurrency, arg.UserID, arg.CurrencyID)
	var i models.WithdrawalWallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Blockchain,
		&i.CurrencyID,
		&i.WithdrawalMinBalance,
		&i.WithdrawalInterval,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.WithdrawalEnabled,
		&i.WithdrawalMinBalanceUsd,
	)
	return &i, err
}

const getWithdrawalWallets = `-- name: GetWithdrawalWallets :many
SELECT id, user_id, blockchain, currency_id, withdrawal_min_balance, withdrawal_interval, created_at, deleted_at, updated_at, withdrawal_enabled, withdrawal_min_balance_usd
FROM withdrawal_wallets
WHERE withdrawal_wallets.user_id = $1::uuid
`

func (q *Queries) GetWithdrawalWallets(ctx context.Context, userID uuid.UUID) ([]*models.WithdrawalWallet, error) {
	rows, err := q.db.Query(ctx, getWithdrawalWallets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.WithdrawalWallet{}
	for rows.Next() {
		var i models.WithdrawalWallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Blockchain,
			&i.CurrencyID,
			&i.WithdrawalMinBalance,
			&i.WithdrawalInterval,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.UpdatedAt,
			&i.WithdrawalEnabled,
			&i.WithdrawalMinBalanceUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const update = `-- name: Update :one
UPDATE withdrawal_wallets
SET withdrawal_enabled=$1,
    withdrawal_min_balance=$2,
    withdrawal_min_balance_usd=$3,
    withdrawal_interval=$4,
    updated_at=now()
WHERE currency_id = $5
  AND user_id = $6
RETURNING id, user_id, blockchain, currency_id, withdrawal_min_balance, withdrawal_interval, created_at, deleted_at, updated_at, withdrawal_enabled, withdrawal_min_balance_usd
`

type UpdateParams struct {
	WithdrawalEnabled       string              `db:"withdrawal_enabled" json:"withdrawal_enabled"`
	WithdrawalMinBalance    decimal.NullDecimal `db:"withdrawal_min_balance" json:"withdrawal_min_balance"`
	WithdrawalMinBalanceUsd decimal.NullDecimal `db:"withdrawal_min_balance_usd" json:"withdrawal_min_balance_usd"`
	WithdrawalInterval      string              `db:"withdrawal_interval" json:"withdrawal_interval"`
	CurrencyID              string              `db:"currency_id" json:"currency_id"`
	UserID                  uuid.UUID           `db:"user_id" json:"user_id"`
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (*models.WithdrawalWallet, error) {
	row := q.db.QueryRow(ctx, update,
		arg.WithdrawalEnabled,
		arg.WithdrawalMinBalance,
		arg.WithdrawalMinBalanceUsd,
		arg.WithdrawalInterval,
		arg.CurrencyID,
		arg.UserID,
	)
	var i models.WithdrawalWallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Blockchain,
		&i.CurrencyID,
		&i.WithdrawalMinBalance,
		&i.WithdrawalInterval,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.UpdatedAt,
		&i.WithdrawalEnabled,
		&i.WithdrawalMinBalanceUsd,
	)
	return &i, err
}
