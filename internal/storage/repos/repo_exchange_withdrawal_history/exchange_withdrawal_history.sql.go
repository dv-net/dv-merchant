// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: exchange_withdrawal_history.sql

package repo_exchange_withdrawal_history

import (
	"context"
	"github.com/dv-net/dv-merchant/internal/models"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const getByID = `-- name: GetByID :one
SELECT id, user_id, exchange_id, exchange_order_id, address, native_amount, fiat_amount, currency, chain, status, txid, created_at, updated_at, fail_reason, exchange_connection_hash
FROM exchange_withdrawal_history
WHERE id = $1
`

func (q *Queries) GetByID(ctx context.Context, id uuid.UUID) (*models.ExchangeWithdrawalHistory, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i models.ExchangeWithdrawalHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExchangeID,
		&i.ExchangeOrderID,
		&i.Address,
		&i.NativeAmount,
		&i.FiatAmount,
		&i.Currency,
		&i.Chain,
		&i.Status,
		&i.Txid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FailReason,
		&i.ExchangeConnectionHash,
	)
	return &i, err
}

const getByUserAndOrderID = `-- name: GetByUserAndOrderID :one
SELECT exchange_withdrawal_history.id, exchange_withdrawal_history.user_id, exchange_withdrawal_history.exchange_id, exchange_withdrawal_history.exchange_order_id, exchange_withdrawal_history.address, exchange_withdrawal_history.native_amount, exchange_withdrawal_history.fiat_amount, exchange_withdrawal_history.currency, exchange_withdrawal_history.chain, exchange_withdrawal_history.status, exchange_withdrawal_history.txid, exchange_withdrawal_history.created_at, exchange_withdrawal_history.updated_at, exchange_withdrawal_history.fail_reason, exchange_withdrawal_history.exchange_connection_hash, exchanges.slug
FROM exchange_withdrawal_history
         LEFT JOIN exchanges ON exchange_withdrawal_history.exchange_id = exchanges.id
WHERE user_id = $1
  AND exchange_withdrawal_history.id = $2
  AND exchange_id = $3
`

type GetByUserAndOrderIDParams struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	ID         uuid.UUID `db:"id" json:"id"`
	ExchangeID uuid.UUID `db:"exchange_id" json:"exchange_id"`
}

type GetByUserAndOrderIDRow struct {
	ID                     uuid.UUID                      `db:"id" json:"id"`
	UserID                 uuid.UUID                      `db:"user_id" json:"user_id"`
	ExchangeID             uuid.UUID                      `db:"exchange_id" json:"exchange_id"`
	ExchangeOrderID        pgtype.Text                    `db:"exchange_order_id" json:"exchange_order_id"`
	Address                string                         `db:"address" json:"address"`
	NativeAmount           decimal.NullDecimal            `db:"native_amount" json:"native_amount"`
	FiatAmount             decimal.NullDecimal            `db:"fiat_amount" json:"fiat_amount"`
	Currency               string                         `db:"currency" json:"currency"`
	Chain                  string                         `db:"chain" json:"chain"`
	Status                 models.WithdrawalHistoryStatus `db:"status" json:"status"`
	Txid                   pgtype.Text                    `db:"txid" json:"txid"`
	CreatedAt              pgtype.Timestamp               `db:"created_at" json:"created_at"`
	UpdatedAt              pgtype.Timestamp               `db:"updated_at" json:"updated_at"`
	FailReason             pgtype.Text                    `db:"fail_reason" json:"fail_reason"`
	ExchangeConnectionHash pgtype.Text                    `db:"exchange_connection_hash" json:"exchange_connection_hash"`
	Slug                   models.ExchangeSlug            `db:"slug" json:"slug"`
}

func (q *Queries) GetByUserAndOrderID(ctx context.Context, arg GetByUserAndOrderIDParams) (*GetByUserAndOrderIDRow, error) {
	row := q.db.QueryRow(ctx, getByUserAndOrderID, arg.UserID, arg.ID, arg.ExchangeID)
	var i GetByUserAndOrderIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExchangeID,
		&i.ExchangeOrderID,
		&i.Address,
		&i.NativeAmount,
		&i.FiatAmount,
		&i.Currency,
		&i.Chain,
		&i.Status,
		&i.Txid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FailReason,
		&i.ExchangeConnectionHash,
		&i.Slug,
	)
	return &i, err
}

const update = `-- name: Update :exec
UPDATE exchange_withdrawal_history
SET updated_at        = NOW(),
    status            = COALESCE($2::varchar, status),
    exchange_order_id = COALESCE($3, exchange_order_id),
    txid              = COALESCE($4, txid),
    native_amount     = COALESCE($5, native_amount),
    fiat_amount       = COALESCE($6, fiat_amount),
    fail_reason       = COALESCE($7, fail_reason),
    exchange_connection_hash = COALESCE($8, exchange_connection_hash)
WHERE id = $1
`

type UpdateParams struct {
	ID                     uuid.UUID           `db:"id" json:"id"`
	Status                 pgtype.Text         `db:"status" json:"status"`
	ExchangeOrderID        pgtype.Text         `db:"exchange_order_id" json:"exchange_order_id"`
	Txid                   pgtype.Text         `db:"txid" json:"txid"`
	NativeAmount           decimal.NullDecimal `db:"native_amount" json:"native_amount"`
	FiatAmount             decimal.NullDecimal `db:"fiat_amount" json:"fiat_amount"`
	FailReason             pgtype.Text         `db:"fail_reason" json:"fail_reason"`
	ExchangeConnectionHash pgtype.Text         `db:"exchange_connection_hash" json:"exchange_connection_hash"`
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) error {
	_, err := q.db.Exec(ctx, update,
		arg.ID,
		arg.Status,
		arg.ExchangeOrderID,
		arg.Txid,
		arg.NativeAmount,
		arg.FiatAmount,
		arg.FailReason,
		arg.ExchangeConnectionHash,
	)
	return err
}
