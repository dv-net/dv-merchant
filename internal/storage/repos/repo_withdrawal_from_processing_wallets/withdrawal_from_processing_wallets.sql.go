// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: withdrawal_from_processing_wallets.sql

package repo_withdrawal_from_processing_wallets

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const deleteWithdrawalFromProcessingWallets = `-- name: DeleteWithdrawalFromProcessingWallets :one
DELETE
FROM withdrawal_from_processing_wallets
WHERE id = $1
  AND store_id = $2
  AND transfer_id IS NULL
RETURNING id, currency_id, store_id, transfer_id, address_from, address_to, amount, amount_usd, created_at, updated_at, request_id
`

type DeleteWithdrawalFromProcessingWalletsParams struct {
	ID      uuid.UUID `db:"id" json:"id"`
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
}

func (q *Queries) DeleteWithdrawalFromProcessingWallets(ctx context.Context, arg DeleteWithdrawalFromProcessingWalletsParams) (*models.WithdrawalFromProcessingWallet, error) {
	row := q.db.QueryRow(ctx, deleteWithdrawalFromProcessingWallets, arg.ID, arg.StoreID)
	var i models.WithdrawalFromProcessingWallet
	err := row.Scan(
		&i.ID,
		&i.CurrencyID,
		&i.StoreID,
		&i.TransferID,
		&i.AddressFrom,
		&i.AddressTo,
		&i.Amount,
		&i.AmountUsd,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestID,
	)
	return &i, err
}

const findByTransferID = `-- name: FindByTransferID :one
SELECT wfpw.id, wfpw.currency_id, wfpw.store_id, wfpw.transfer_id, wfpw.address_from, wfpw.address_to, wfpw.amount, wfpw.amount_usd, wfpw.created_at, wfpw.updated_at, wfpw.request_id,
       coalesce(t.kind, ''),
       coalesce(t.stage, ''),
       coalesce(t.status, '')
FROM withdrawal_from_processing_wallets wfpw
         INNER JOIN transfers t ON wfpw.transfer_id = t.id
WHERE t.id = $1
LIMIT 1
`

type FindByTransferIDRow struct {
	WithdrawalFromProcessingWallet models.WithdrawalFromProcessingWallet `db:"withdrawal_from_processing_wallet" json:"withdrawal_from_processing_wallet"`
	Kind                           models.TransferKind                   `db:"kind" json:"kind"`
	Stage                          models.TransferStage                  `db:"stage" json:"stage"`
	Status                         models.TransferStatus                 `db:"status" json:"status"`
}

func (q *Queries) FindByTransferID(ctx context.Context, id uuid.UUID) (*FindByTransferIDRow, error) {
	row := q.db.QueryRow(ctx, findByTransferID, id)
	var i FindByTransferIDRow
	err := row.Scan(
		&i.WithdrawalFromProcessingWallet.ID,
		&i.WithdrawalFromProcessingWallet.CurrencyID,
		&i.WithdrawalFromProcessingWallet.StoreID,
		&i.WithdrawalFromProcessingWallet.TransferID,
		&i.WithdrawalFromProcessingWallet.AddressFrom,
		&i.WithdrawalFromProcessingWallet.AddressTo,
		&i.WithdrawalFromProcessingWallet.Amount,
		&i.WithdrawalFromProcessingWallet.AmountUsd,
		&i.WithdrawalFromProcessingWallet.CreatedAt,
		&i.WithdrawalFromProcessingWallet.UpdatedAt,
		&i.WithdrawalFromProcessingWallet.RequestID,
		&i.Kind,
		&i.Stage,
		&i.Status,
	)
	return &i, err
}

const getByID = `-- name: GetByID :one
SELECT id, currency_id, store_id, transfer_id, address_from, address_to, amount, amount_usd, created_at, updated_at, request_id
FROM withdrawal_from_processing_wallets
WHERE id = $1
  AND store_id = $2
`

type GetByIDParams struct {
	ID      uuid.UUID `db:"id" json:"id"`
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
}

func (q *Queries) GetByID(ctx context.Context, arg GetByIDParams) (*models.WithdrawalFromProcessingWallet, error) {
	row := q.db.QueryRow(ctx, getByID, arg.ID, arg.StoreID)
	var i models.WithdrawalFromProcessingWallet
	err := row.Scan(
		&i.ID,
		&i.CurrencyID,
		&i.StoreID,
		&i.TransferID,
		&i.AddressFrom,
		&i.AddressTo,
		&i.Amount,
		&i.AmountUsd,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.RequestID,
	)
	return &i, err
}

const getPrefetchHistoryByUserID = `-- name: GetPrefetchHistoryByUserID :many
SELECT wfpw.id, wfpw.currency_id, wfpw.store_id, wfpw.transfer_id, wfpw.address_from, wfpw.address_to, wfpw.amount, wfpw.amount_usd, wfpw.created_at, wfpw.updated_at, wfpw.request_id, c.id, c.code, c.name, c.precision, c.is_fiat, c.blockchain, c.contract_address, c.withdrawal_min_balance, c.has_balance, c.status, c.sort_order, c.min_confirmation, c.created_at, c.updated_at, c.is_stablecoin, c.currency_label, c.token_label, (wfpw.amount * rate.exchange_rate) ::decimal as amount_usd
FROM withdrawal_from_processing_wallets wfpw
         INNER JOIN currencies c on c.id = wfpw.currency_id
         INNER JOIN stores s on s.id = wfpw.store_id
         LEFT JOIN (SELECT unnest($2::text[])     AS currency_id,
                           unnest($3::decimal[]) AS exchange_rate) rate
                   on c.id = rate.currency_id
WHERE s.user_id = $1
  AND wfpw.transfer_id IS NULL
`

type GetPrefetchHistoryByUserIDParams struct {
	UserID       uuid.UUID         `db:"user_id" json:"user_id"`
	CurrencyIds  []string          `db:"currency_ids" json:"currency_ids"`
	CurrencyRate []decimal.Decimal `db:"currency_rate" json:"currency_rate"`
}

type GetPrefetchHistoryByUserIDRow struct {
	WithdrawalFromProcessingWallet models.WithdrawalFromProcessingWallet `db:"withdrawal_from_processing_wallet" json:"withdrawal_from_processing_wallet"`
	Currency                       models.Currency                       `db:"currency" json:"currency"`
	AmountUsd                      decimal.Decimal                       `db:"amount_usd" json:"amount_usd"`
}

func (q *Queries) GetPrefetchHistoryByUserID(ctx context.Context, arg GetPrefetchHistoryByUserIDParams) ([]*GetPrefetchHistoryByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getPrefetchHistoryByUserID, arg.UserID, arg.CurrencyIds, arg.CurrencyRate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPrefetchHistoryByUserIDRow{}
	for rows.Next() {
		var i GetPrefetchHistoryByUserIDRow
		if err := rows.Scan(
			&i.WithdrawalFromProcessingWallet.ID,
			&i.WithdrawalFromProcessingWallet.CurrencyID,
			&i.WithdrawalFromProcessingWallet.StoreID,
			&i.WithdrawalFromProcessingWallet.TransferID,
			&i.WithdrawalFromProcessingWallet.AddressFrom,
			&i.WithdrawalFromProcessingWallet.AddressTo,
			&i.WithdrawalFromProcessingWallet.Amount,
			&i.WithdrawalFromProcessingWallet.AmountUsd,
			&i.WithdrawalFromProcessingWallet.CreatedAt,
			&i.WithdrawalFromProcessingWallet.UpdatedAt,
			&i.WithdrawalFromProcessingWallet.RequestID,
			&i.Currency.ID,
			&i.Currency.Code,
			&i.Currency.Name,
			&i.Currency.Precision,
			&i.Currency.IsFiat,
			&i.Currency.Blockchain,
			&i.Currency.ContractAddress,
			&i.Currency.WithdrawalMinBalance,
			&i.Currency.HasBalance,
			&i.Currency.Status,
			&i.Currency.SortOrder,
			&i.Currency.MinConfirmation,
			&i.Currency.CreatedAt,
			&i.Currency.UpdatedAt,
			&i.Currency.IsStablecoin,
			&i.Currency.CurrencyLabel,
			&i.Currency.TokenLabel,
			&i.AmountUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQueuedWithdrawalsWithCurrencyAndUser = `-- name: GetQueuedWithdrawalsWithCurrencyAndUser :many
SELECT wfpw.id, wfpw.currency_id, wfpw.store_id, wfpw.transfer_id, wfpw.address_from, wfpw.address_to, wfpw.amount, wfpw.amount_usd, wfpw.created_at, wfpw.updated_at, wfpw.request_id, u.id, u.email, u.email_verified_at, u.password, u.remember_token, u.processing_owner_id, u.location, u.language, u.rate_source, u.created_at, u.updated_at, u.deleted_at, u.banned, u.exchange_slug, u.rate_scale, u.dvnet_token, c.id, c.code, c.name, c.precision, c.is_fiat, c.blockchain, c.contract_address, c.withdrawal_min_balance, c.has_balance, c.status, c.sort_order, c.min_confirmation, c.created_at, c.updated_at, c.is_stablecoin, c.currency_label, c.token_label
FROM withdrawal_from_processing_wallets wfpw
         INNER JOIN currencies c on c.id = wfpw.currency_id
         INNER JOIN stores s on s.id = wfpw.store_id
         INNER JOIN users u on s.user_id = u.id
WHERE wfpw.transfer_id IS NULL
`

type GetQueuedWithdrawalsWithCurrencyAndUserRow struct {
	WithdrawalFromProcessingWallet models.WithdrawalFromProcessingWallet `db:"withdrawal_from_processing_wallet" json:"withdrawal_from_processing_wallet"`
	User                           models.User                           `db:"user" json:"user"`
	Currency                       models.Currency                       `db:"currency" json:"currency"`
}

func (q *Queries) GetQueuedWithdrawalsWithCurrencyAndUser(ctx context.Context) ([]*GetQueuedWithdrawalsWithCurrencyAndUserRow, error) {
	rows, err := q.db.Query(ctx, getQueuedWithdrawalsWithCurrencyAndUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetQueuedWithdrawalsWithCurrencyAndUserRow{}
	for rows.Next() {
		var i GetQueuedWithdrawalsWithCurrencyAndUserRow
		if err := rows.Scan(
			&i.WithdrawalFromProcessingWallet.ID,
			&i.WithdrawalFromProcessingWallet.CurrencyID,
			&i.WithdrawalFromProcessingWallet.StoreID,
			&i.WithdrawalFromProcessingWallet.TransferID,
			&i.WithdrawalFromProcessingWallet.AddressFrom,
			&i.WithdrawalFromProcessingWallet.AddressTo,
			&i.WithdrawalFromProcessingWallet.Amount,
			&i.WithdrawalFromProcessingWallet.AmountUsd,
			&i.WithdrawalFromProcessingWallet.CreatedAt,
			&i.WithdrawalFromProcessingWallet.UpdatedAt,
			&i.WithdrawalFromProcessingWallet.RequestID,
			&i.User.ID,
			&i.User.Email,
			&i.User.EmailVerifiedAt,
			&i.User.Password,
			&i.User.RememberToken,
			&i.User.ProcessingOwnerID,
			&i.User.Location,
			&i.User.Language,
			&i.User.RateSource,
			&i.User.CreatedAt,
			&i.User.UpdatedAt,
			&i.User.DeletedAt,
			&i.User.Banned,
			&i.User.ExchangeSlug,
			&i.User.RateScale,
			&i.User.DvnetToken,
			&i.Currency.ID,
			&i.Currency.Code,
			&i.Currency.Name,
			&i.Currency.Precision,
			&i.Currency.IsFiat,
			&i.Currency.Blockchain,
			&i.Currency.ContractAddress,
			&i.Currency.WithdrawalMinBalance,
			&i.Currency.HasBalance,
			&i.Currency.Status,
			&i.Currency.SortOrder,
			&i.Currency.MinConfirmation,
			&i.Currency.CreatedAt,
			&i.Currency.UpdatedAt,
			&i.Currency.IsStablecoin,
			&i.Currency.CurrencyLabel,
			&i.Currency.TokenLabel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWithdrawalWithTransfer = `-- name: GetWithdrawalWithTransfer :one
SELECT wfpw.id, wfpw.currency_id, wfpw.store_id, wfpw.transfer_id, wfpw.address_from, wfpw.address_to, wfpw.amount, wfpw.amount_usd, wfpw.created_at, wfpw.updated_at, wfpw.request_id,
       coalesce(t.kind, ''),
       coalesce(t.stage, ''),
       coalesce(t.status, ''),
       coalesce(t.tx_hash, ''),
       coalesce(t.message, '')
FROM withdrawal_from_processing_wallets wfpw
         LEFT JOIN transfers t ON wfpw.transfer_id = t.id
WHERE wfpw.id = $1
  AND wfpw.store_id = $2
`

type GetWithdrawalWithTransferParams struct {
	ID      uuid.UUID `db:"id" json:"id"`
	StoreID uuid.UUID `db:"store_id" json:"store_id"`
}

type GetWithdrawalWithTransferRow struct {
	WithdrawalFromProcessingWallet models.WithdrawalFromProcessingWallet `db:"withdrawal_from_processing_wallet" json:"withdrawal_from_processing_wallet"`
	Kind                           models.TransferKind                   `db:"kind" json:"kind"`
	Stage                          models.TransferStage                  `db:"stage" json:"stage"`
	Status                         models.TransferStatus                 `db:"status" json:"status"`
	TxHash                         *string                               `db:"tx_hash" json:"tx_hash"`
	Message                        *string                               `db:"message" json:"message"`
}

func (q *Queries) GetWithdrawalWithTransfer(ctx context.Context, arg GetWithdrawalWithTransferParams) (*GetWithdrawalWithTransferRow, error) {
	row := q.db.QueryRow(ctx, getWithdrawalWithTransfer, arg.ID, arg.StoreID)
	var i GetWithdrawalWithTransferRow
	err := row.Scan(
		&i.WithdrawalFromProcessingWallet.ID,
		&i.WithdrawalFromProcessingWallet.CurrencyID,
		&i.WithdrawalFromProcessingWallet.StoreID,
		&i.WithdrawalFromProcessingWallet.TransferID,
		&i.WithdrawalFromProcessingWallet.AddressFrom,
		&i.WithdrawalFromProcessingWallet.AddressTo,
		&i.WithdrawalFromProcessingWallet.Amount,
		&i.WithdrawalFromProcessingWallet.AmountUsd,
		&i.WithdrawalFromProcessingWallet.CreatedAt,
		&i.WithdrawalFromProcessingWallet.UpdatedAt,
		&i.WithdrawalFromProcessingWallet.RequestID,
		&i.Kind,
		&i.Stage,
		&i.Status,
		&i.TxHash,
		&i.Message,
	)
	return &i, err
}

const isWithdrawalExistByRequestID = `-- name: IsWithdrawalExistByRequestID :one
SELECT EXISTS (SELECT 1
               FROM withdrawal_from_processing_wallets wfpw
                        LEFT JOIN transfers t ON wfpw.transfer_id = t.id
               WHERE wfpw.request_id = $1
                 AND (
                   wfpw.transfer_id IS NULL
                       OR t.status = 'completed'
                   ))
`

func (q *Queries) IsWithdrawalExistByRequestID(ctx context.Context, requestID *string) (bool, error) {
	row := q.db.QueryRow(ctx, isWithdrawalExistByRequestID, requestID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTransferID = `-- name: UpdateTransferID :exec
UPDATE withdrawal_from_processing_wallets
SET transfer_id = $1::uuid,
    amount_usd  = $2::numeric
WHERE id = $3::uuid
`

type UpdateTransferIDParams struct {
	TransferID uuid.UUID       `db:"transfer_id" json:"transfer_id"`
	AmountUsd  decimal.Decimal `db:"amount_usd" json:"amount_usd"`
	ID         uuid.UUID       `db:"id" json:"id"`
}

func (q *Queries) UpdateTransferID(ctx context.Context, arg UpdateTransferIDParams) error {
	_, err := q.db.Exec(ctx, updateTransferID, arg.TransferID, arg.AmountUsd, arg.ID)
	return err
}
