// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wallets.sql

package repo_wallets

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const getByStore = `-- name: GetByStore :one
SELECT id, store_id, store_external_id, created_at, updated_at, deleted_at, email, ip_address, untrusted_email, locale
FROM wallets
WHERE deleted_at IS NULL
  AND store_id = $1
  AND store_external_id = $2
LIMIT 1
`

type GetByStoreParams struct {
	StoreID         uuid.UUID `db:"store_id" json:"store_id"`
	StoreExternalID string    `db:"store_external_id" json:"store_external_id"`
}

func (q *Queries) GetByStore(ctx context.Context, arg GetByStoreParams) (*models.Wallet, error) {
	row := q.db.QueryRow(ctx, getByStore, arg.StoreID, arg.StoreExternalID)
	var i models.Wallet
	err := row.Scan(
		&i.ID,
		&i.StoreID,
		&i.StoreExternalID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Email,
		&i.IpAddress,
		&i.UntrustedEmail,
		&i.Locale,
	)
	return &i, err
}

const getFullDataByID = `-- name: GetFullDataByID :one
select w.id, w.store_id, w.store_external_id, w.created_at, w.updated_at, w.deleted_at, w.email, w.ip_address, w.untrusted_email, w.locale, st.id, st.user_id, st.name, st.site, st.currency_id, st.rate_source, st.return_url, st.success_url, st.rate_scale, st.status, st.minimal_payment, st.created_at, st.updated_at, st.deleted_at, st.public_payment_form_enabled
from wallets w
         left join stores st on w.store_id = st.id
where w.id = $1
`

type GetFullDataByIDRow struct {
	Wallet models.Wallet `db:"wallet" json:"wallet"`
	Store  models.Store  `db:"store" json:"store"`
}

func (q *Queries) GetFullDataByID(ctx context.Context, id uuid.UUID) (*GetFullDataByIDRow, error) {
	row := q.db.QueryRow(ctx, getFullDataByID, id)
	var i GetFullDataByIDRow
	err := row.Scan(
		&i.Wallet.ID,
		&i.Wallet.StoreID,
		&i.Wallet.StoreExternalID,
		&i.Wallet.CreatedAt,
		&i.Wallet.UpdatedAt,
		&i.Wallet.DeletedAt,
		&i.Wallet.Email,
		&i.Wallet.IpAddress,
		&i.Wallet.UntrustedEmail,
		&i.Wallet.Locale,
		&i.Store.ID,
		&i.Store.UserID,
		&i.Store.Name,
		&i.Store.Site,
		&i.Store.CurrencyID,
		&i.Store.RateSource,
		&i.Store.ReturnUrl,
		&i.Store.SuccessUrl,
		&i.Store.RateScale,
		&i.Store.Status,
		&i.Store.MinimalPayment,
		&i.Store.CreatedAt,
		&i.Store.UpdatedAt,
		&i.Store.DeletedAt,
		&i.Store.PublicPaymentFormEnabled,
	)
	return &i, err
}

const getWalletWithStore = `-- name: GetWalletWithStore :many
SELECT w.id as wallet_id, w.store_external_id, wa.address, wa.currency_id, s.id, s.user_id, s.name, s.site, s.currency_id, s.rate_source, s.return_url, s.success_url, s.rate_scale, s.status, s.minimal_payment, s.created_at, s.updated_at, s.deleted_at, s.public_payment_form_enabled
FROM wallets w
         INNER JOIN stores s ON w.store_id = s.id
         INNER JOIN wallet_addresses wa ON w.id = wa.wallet_id
WHERE wa.address = $1
  AND s.user_id = $2
  AND w.deleted_at IS NULL
`

type GetWalletWithStoreParams struct {
	Address string    `db:"address" json:"address"`
	UserID  uuid.UUID `db:"user_id" json:"user_id"`
}

type GetWalletWithStoreRow struct {
	WalletID        uuid.UUID    `db:"wallet_id" json:"wallet_id"`
	StoreExternalID string       `db:"store_external_id" json:"store_external_id"`
	Address         string       `db:"address" json:"address"`
	CurrencyID      string       `db:"currency_id" json:"currency_id"`
	Store           models.Store `db:"store" json:"store"`
}

func (q *Queries) GetWalletWithStore(ctx context.Context, arg GetWalletWithStoreParams) ([]*GetWalletWithStoreRow, error) {
	rows, err := q.db.Query(ctx, getWalletWithStore, arg.Address, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWalletWithStoreRow{}
	for rows.Next() {
		var i GetWalletWithStoreRow
		if err := rows.Scan(
			&i.WalletID,
			&i.StoreExternalID,
			&i.Address,
			&i.CurrencyID,
			&i.Store.ID,
			&i.Store.UserID,
			&i.Store.Name,
			&i.Store.Site,
			&i.Store.CurrencyID,
			&i.Store.RateSource,
			&i.Store.ReturnUrl,
			&i.Store.SuccessUrl,
			&i.Store.RateScale,
			&i.Store.Status,
			&i.Store.MinimalPayment,
			&i.Store.CreatedAt,
			&i.Store.UpdatedAt,
			&i.Store.DeletedAt,
			&i.Store.PublicPaymentFormEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreByStore = `-- name: RestoreByStore :many
UPDATE wallets SET deleted_at = NULL, updated_at = now() WHERE store_id = $1 RETURNING id
`

func (q *Queries) RestoreByStore(ctx context.Context, storeID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, restoreByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchByParam = `-- name: SearchByParam :many
WITH deposit_stats AS (
    SELECT t.to_address,
           t.currency_id,
           COUNT(*)      AS tx_count,
           SUM(t.amount) AS total_deposit
    FROM transactions t
    WHERE t.type = 'deposit'
    GROUP BY t.to_address, t.currency_id
)
SELECT w.id                                   AS "wallet_id",
       w.created_at                           AS "wallet_created_at",
       w.store_external_id                    AS "store_external_id",
       s.id                                   AS "store_id",
       s.name                                 AS "store_name",
       w.email                                AS "email",
       w.untrusted_email                      AS "untrusted_email",
       wa.address                             AS "address",
       wa.id                                  AS "wallet_address_id",
       wa.blockchain                          AS "blockchain",
       wa.currency_id                         AS "currency_id",
       wa.amount                              AS "amount",
       c.code                                 AS "currency_code",
       COALESCE(ds.tx_count, 0)::numeric      AS "deposits_count",
       COALESCE(ds.total_deposit, 0)::numeric AS "deposits_sum"
FROM wallets AS w
         JOIN wallet_addresses AS wa ON w.id = wa.wallet_id
         JOIN currencies AS c ON c.id = wa.currency_id
         JOIN stores AS s ON s.id = w.store_id
         JOIN user_stores us ON s.id = us.store_id AND us.user_id = wa.user_id
         LEFT JOIN deposit_stats ds ON ds.to_address = wa.address AND ds.currency_id = wa.currency_id
WHERE wa.user_id = $1
  AND (
    w.ip_address = $2
        OR w.email = $2
        OR w.untrusted_email = $2
        OR wa.address = $2
        OR wa.address = lower($2)
        OR w.store_external_id = $2
)
`

type SearchByParamParams struct {
	UserID   uuid.UUID   `db:"user_id" json:"user_id"`
	Criteria pgtype.Text `db:"criteria" json:"criteria"`
}

type SearchByParamRow struct {
	WalletID        uuid.UUID         `db:"wallet_id" json:"wallet_id"`
	WalletCreatedAt pgtype.Timestamp  `db:"wallet_created_at" json:"wallet_created_at"`
	StoreExternalID string            `db:"store_external_id" json:"store_external_id"`
	StoreID         uuid.UUID         `db:"store_id" json:"store_id"`
	StoreName       string            `db:"store_name" json:"store_name"`
	Email           pgtype.Text       `db:"email" json:"email"`
	UntrustedEmail  pgtype.Text       `db:"untrusted_email" json:"untrusted_email"`
	Address         string            `db:"address" json:"address"`
	WalletAddressID uuid.UUID         `db:"wallet_address_id" json:"wallet_address_id"`
	Blockchain      models.Blockchain `db:"blockchain" json:"blockchain"`
	CurrencyID      string            `db:"currency_id" json:"currency_id"`
	Amount          decimal.Decimal   `db:"amount" json:"amount"`
	CurrencyCode    string            `db:"currency_code" json:"currency_code"`
	DepositsCount   decimal.Decimal   `db:"deposits_count" json:"deposits_count"`
	DepositsSum     decimal.Decimal   `db:"deposits_sum" json:"deposits_sum"`
}

func (q *Queries) SearchByParam(ctx context.Context, arg SearchByParamParams) ([]*SearchByParamRow, error) {
	rows, err := q.db.Query(ctx, searchByParam, arg.UserID, arg.Criteria)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchByParamRow{}
	for rows.Next() {
		var i SearchByParamRow
		if err := rows.Scan(
			&i.WalletID,
			&i.WalletCreatedAt,
			&i.StoreExternalID,
			&i.StoreID,
			&i.StoreName,
			&i.Email,
			&i.UntrustedEmail,
			&i.Address,
			&i.WalletAddressID,
			&i.Blockchain,
			&i.CurrencyID,
			&i.Amount,
			&i.CurrencyCode,
			&i.DepositsCount,
			&i.DepositsSum,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteByStore = `-- name: SoftDeleteByStore :many
UPDATE wallets SET deleted_at = now(), updated_at = now() WHERE store_id = $1 RETURNING id
`

func (q *Queries) SoftDeleteByStore(ctx context.Context, storeID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, softDeleteByStore, storeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.UUID{}
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE wallets
SET email=$1,
    updated_at = now()
WHERE id = $2
`

type UpdateUserEmailParams struct {
	Email pgtype.Text `db:"email" json:"email"`
	ID    uuid.UUID   `db:"id" json:"id"`
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserEmail, arg.Email, arg.ID)
	return err
}

const updateUserIPAddress = `-- name: UpdateUserIPAddress :exec
UPDATE wallets
SET ip_address=$1,
    updated_at = now()
WHERE id = $2
`

type UpdateUserIPAddressParams struct {
	IpAddress pgtype.Text `db:"ip_address" json:"ip_address"`
	ID        uuid.UUID   `db:"id" json:"id"`
}

func (q *Queries) UpdateUserIPAddress(ctx context.Context, arg UpdateUserIPAddressParams) error {
	_, err := q.db.Exec(ctx, updateUserIPAddress, arg.IpAddress, arg.ID)
	return err
}

const updateUserLocale = `-- name: UpdateUserLocale :exec
UPDATE wallets
SET locale=$1,
    updated_at = now()
WHERE id = $2
`

type UpdateUserLocaleParams struct {
	Locale string    `db:"locale" json:"locale"`
	ID     uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) UpdateUserLocale(ctx context.Context, arg UpdateUserLocaleParams) error {
	_, err := q.db.Exec(ctx, updateUserLocale, arg.Locale, arg.ID)
	return err
}

const updateUserUntrustedEmail = `-- name: UpdateUserUntrustedEmail :exec
UPDATE wallets
SET untrusted_email=$1,
    updated_at = now()
WHERE id = $2
`

type UpdateUserUntrustedEmailParams struct {
	UntrustedEmail pgtype.Text `db:"untrusted_email" json:"untrusted_email"`
	ID             uuid.UUID   `db:"id" json:"id"`
}

func (q *Queries) UpdateUserUntrustedEmail(ctx context.Context, arg UpdateUserUntrustedEmailParams) error {
	_, err := q.db.Exec(ctx, updateUserUntrustedEmail, arg.UntrustedEmail, arg.ID)
	return err
}
