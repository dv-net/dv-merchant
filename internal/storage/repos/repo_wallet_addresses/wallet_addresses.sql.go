// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: wallet_addresses.sql

package repo_wallet_addresses

import (
	"context"
	"github.com/dv-net/dv-merchant/internal/models"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const filterOwnerWalletAddresses = `-- name: FilterOwnerWalletAddresses :many
SELECT address, user_id, id as wallet_addresses_id
FROM wallet_addresses
WHERE user_id = $1
  AND address in (select unnest($2::text[]))
  AND deleted_at IS NULL
`

type FilterOwnerWalletAddressesRow struct {
	Address           string    `db:"address" json:"address"`
	UserID            uuid.UUID `db:"user_id" json:"user_id"`
	WalletAddressesID uuid.UUID `db:"wallet_addresses_id" json:"wallet_addresses_id"`
}

func (q *Queries) FilterOwnerWalletAddresses(ctx context.Context, userID uuid.UUID, column2 []string) ([]*FilterOwnerWalletAddressesRow, error) {
	rows, err := q.db.Query(ctx, filterOwnerWalletAddresses, userID, column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FilterOwnerWalletAddressesRow{}
	for rows.Next() {
		var i FilterOwnerWalletAddressesRow
		if err := rows.Scan(&i.Address, &i.UserID, &i.WalletAddressesID); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAddressForMultiWithdrawal = `-- name: GetAddressForMultiWithdrawal :one
SELECT wa.currency_id,
       array_agg(distinct wa.address)::varchar[]        AS addresses,
       SUM(wa.amount)::numeric                          AS total_amount,
       (SUM(wa.amount) * MAX(r.exchange_rate))::numeric AS amount_usd
FROM wallet_addresses wa
         INNER JOIN currencies c
                    ON wa.currency_id = c.id
         LEFT JOIN (SELECT unnest($1::text[])     AS currency_id,
                           unnest($2::decimal[]) AS exchange_rate) r
                   ON c.id = r.currency_id
WHERE wa.user_id = $3
  AND wa.currency_id = $4
  AND wa.address NOT IN (SELECT unnest(from_addresses)
                         FROM transfers
                         WHERE user_id = $3
                           AND kind = 'from_address'
                           AND transfers.currency_id = $4
                           AND transfers.blockchain = $5
                           AND (
                             transfers.stage = 'in_progress'
                                 OR (
                                 transfers.stage = 'completed'
                                     AND updated_at > (NOW() - INTERVAL '5 minutes')
                                 )
                                 OR (
                                 transfers.stage = 'failed'
                                     AND created_at > (NOW() - INTERVAL '30 minutes')
                                 )
                             ))
  AND wa.amount > 0
  AND (
    (($6::numeric IS NULL OR $6::numeric = 0) AND wa.amount > 0)
        -- Only addresses with low balance (lower than min for withdrawal) is required --
        OR (wa.amount * r.exchange_rate)::decimal < $6::numeric
    )
  AND (
    (($7::numeric IS NULL OR $7 = 0) AND wa.amount > 0)
        -- Only addresses with low balance (lower than min for withdrawal) is required --
        OR wa.amount < $7::numeric
    )
GROUP BY wa.user_id, wa.currency_id
HAVING ($7 IS NULL OR SUM(wa.amount) >= $7::numeric)
   AND ($6 IS NULL OR (SUM(wa.amount) * MAX(r.exchange_rate))::numeric > $6)
ORDER BY (SUM(wa.amount) * MAX(r.exchange_rate))::decimal DESC
LIMIT 1
`

type GetAddressForMultiWithdrawalParams struct {
	CurrencyIds  []string            `db:"currency_ids" json:"currency_ids"`
	CurrencyRate []decimal.Decimal   `db:"currency_rate" json:"currency_rate"`
	UserID       uuid.UUID           `db:"user_id" json:"user_id"`
	Currency     string              `db:"currency" json:"currency"`
	Blockchain   models.Blockchain   `db:"blockchain" json:"blockchain"`
	MinUsd       decimal.NullDecimal `db:"min_usd" json:"min_usd"`
	MinAmount    decimal.NullDecimal `db:"min_amount" json:"min_amount"`
}

type GetAddressForMultiWithdrawalRow struct {
	CurrencyID  string          `db:"currency_id" json:"currency_id"`
	Addresses   []string        `db:"addresses" json:"addresses"`
	TotalAmount decimal.Decimal `db:"total_amount" json:"total_amount"`
	AmountUsd   decimal.Decimal `db:"amount_usd" json:"amount_usd"`
}

func (q *Queries) GetAddressForMultiWithdrawal(ctx context.Context, arg GetAddressForMultiWithdrawalParams) (*GetAddressForMultiWithdrawalRow, error) {
	row := q.db.QueryRow(ctx, getAddressForMultiWithdrawal,
		arg.CurrencyIds,
		arg.CurrencyRate,
		arg.UserID,
		arg.Currency,
		arg.Blockchain,
		arg.MinUsd,
		arg.MinAmount,
	)
	var i GetAddressForMultiWithdrawalRow
	err := row.Scan(
		&i.CurrencyID,
		&i.Addresses,
		&i.TotalAmount,
		&i.AmountUsd,
	)
	return &i, err
}

const getAddressForWithdrawal = `-- name: GetAddressForWithdrawal :one
select wallet_addresses.id, wallet_addresses.wallet_id, wallet_addresses.user_id, wallet_addresses.currency_id, wallet_addresses.blockchain, wallet_addresses.address, wallet_addresses.amount, wallet_addresses.created_at, wallet_addresses.updated_at, wallet_addresses.deleted_at, wallet_addresses.dirty, currencies.id, currencies.code, currencies.name, currencies.precision, currencies.is_fiat, currencies.blockchain, currencies.contract_address, currencies.withdrawal_min_balance, currencies.has_balance, currencies.status, currencies.sort_order, currencies.min_confirmation, currencies.created_at, currencies.updated_at, currencies.is_stablecoin, currencies.currency_label, currencies.token_label, (amount * exchange_rate)::decimal as amount_usd
from wallet_addresses
         left join currencies
                   on wallet_addresses.currency_id = currencies.id
         left join
     (SELECT unnest($5::text[])     AS currency_id,
             unnest($6::decimal[]) AS exchange_rate) rate
     on currencies.id = rate.currency_id
where wallet_addresses.user_id = $1
  and wallet_addresses.currency_id = $2
  and wallet_addresses.amount >= $3
  and wallet_addresses.address not in (select unnest(from_addresses)
                                       from transfers
                                       where user_id = $1
                                         and kind = 'from_address'
                                         and transfers.currency_id = $2
                                         and transfers.blockchain = $4
                                         and (transfers.stage = 'in_progress'
                                           or
                                              (transfers.stage = 'completed' and
                                               updated_at > (now() - interval '5 minutes'))
                                           or
                                              (transfers.stage = 'failed' and
                                               created_at > (now() - interval '30 minutes'))
                                           ))
  and ($7::numeric is null or (amount * exchange_rate)::decimal >= $7::numeric)
order by amount_usd desc
limit 1
`

type GetAddressForWithdrawalParams struct {
	UserID       uuid.UUID         `db:"user_id" json:"user_id"`
	CurrencyID   string            `db:"currency_id" json:"currency_id"`
	Amount       decimal.Decimal   `db:"amount" json:"amount"`
	Blockchain   models.Blockchain `db:"blockchain" json:"blockchain"`
	CurrencyIds  []string          `db:"currency_ids" json:"currency_ids"`
	CurrencyRate []decimal.Decimal `db:"currency_rate" json:"currency_rate"`
	MinUsd       decimal.Decimal   `db:"min_usd" json:"min_usd"`
}

type GetAddressForWithdrawalRow struct {
	ID                   uuid.UUID          `db:"id" json:"id"`
	WalletID             uuid.UUID          `db:"wallet_id" json:"wallet_id"`
	UserID               uuid.UUID          `db:"user_id" json:"user_id"`
	CurrencyID           string             `db:"currency_id" json:"currency_id"`
	Blockchain           models.Blockchain  `db:"blockchain" json:"blockchain"`
	Address              string             `db:"address" json:"address"`
	Amount               decimal.Decimal    `db:"amount" json:"amount"`
	CreatedAt            pgtype.Timestamp   `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp   `db:"updated_at" json:"updated_at"`
	DeletedAt            pgtype.Timestamp   `db:"deleted_at" json:"deleted_at"`
	Dirty                bool               `db:"dirty" json:"dirty"`
	ID_2                 pgtype.Text        `db:"id_2" json:"id_2"`
	Code                 pgtype.Text        `db:"code" json:"code"`
	Name                 pgtype.Text        `db:"name" json:"name"`
	Precision            pgtype.Int2        `db:"precision" json:"precision"`
	IsFiat               pgtype.Bool        `db:"is_fiat" json:"is_fiat"`
	Blockchain_2         *models.Blockchain `db:"blockchain_2" json:"blockchain_2"`
	ContractAddress      pgtype.Text        `db:"contract_address" json:"contract_address"`
	WithdrawalMinBalance *decimal.Decimal   `db:"withdrawal_min_balance" json:"withdrawal_min_balance"`
	HasBalance           pgtype.Bool        `db:"has_balance" json:"has_balance"`
	Status               pgtype.Bool        `db:"status" json:"status"`
	SortOrder            pgtype.Int2        `db:"sort_order" json:"sort_order"`
	MinConfirmation      pgtype.Int2        `db:"min_confirmation" json:"min_confirmation"`
	CreatedAt_2          pgtype.Timestamp   `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2          pgtype.Timestamp   `db:"updated_at_2" json:"updated_at_2"`
	IsStablecoin         pgtype.Bool        `db:"is_stablecoin" json:"is_stablecoin"`
	CurrencyLabel        pgtype.Text        `db:"currency_label" json:"currency_label"`
	TokenLabel           pgtype.Text        `db:"token_label" json:"token_label"`
	AmountUsd            decimal.Decimal    `db:"amount_usd" json:"amount_usd"`
}

func (q *Queries) GetAddressForWithdrawal(ctx context.Context, arg GetAddressForWithdrawalParams) (*GetAddressForWithdrawalRow, error) {
	row := q.db.QueryRow(ctx, getAddressForWithdrawal,
		arg.UserID,
		arg.CurrencyID,
		arg.Amount,
		arg.Blockchain,
		arg.CurrencyIds,
		arg.CurrencyRate,
		arg.MinUsd,
	)
	var i GetAddressForWithdrawalRow
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.UserID,
		&i.CurrencyID,
		&i.Blockchain,
		&i.Address,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Dirty,
		&i.ID_2,
		&i.Code,
		&i.Name,
		&i.Precision,
		&i.IsFiat,
		&i.Blockchain_2,
		&i.ContractAddress,
		&i.WithdrawalMinBalance,
		&i.HasBalance,
		&i.Status,
		&i.SortOrder,
		&i.MinConfirmation,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.IsStablecoin,
		&i.CurrencyLabel,
		&i.TokenLabel,
		&i.AmountUsd,
	)
	return &i, err
}

const getAllClearByWalletID = `-- name: GetAllClearByWalletID :many
SELECT id, wallet_id, user_id, currency_id, blockchain, address, amount, created_at, updated_at, deleted_at, dirty
FROM wallet_addresses
WHERE wallet_id = $1
  AND dirty = false
  AND deleted_at IS NULL
  and currency_id = ANY ($2::varchar[])
`

func (q *Queries) GetAllClearByWalletID(ctx context.Context, walletID uuid.UUID, currencyIds []string) ([]*models.WalletAddress, error) {
	rows, err := q.db.Query(ctx, getAllClearByWalletID, walletID, currencyIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.WalletAddress{}
	for rows.Next() {
		var i models.WalletAddress
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.UserID,
			&i.CurrencyID,
			&i.Blockchain,
			&i.Address,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Dirty,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByWalletIDAndCurrencyID = `-- name: GetByWalletIDAndCurrencyID :one
SELECT id, wallet_id, user_id, currency_id, blockchain, address, amount, created_at, updated_at, deleted_at, dirty
FROM wallet_addresses
WHERE wallet_id = $1
  AND currency_id = $2
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetByWalletIDAndCurrencyID(ctx context.Context, walletID uuid.UUID, currencyID string) (*models.WalletAddress, error) {
	row := q.db.QueryRow(ctx, getByWalletIDAndCurrencyID, walletID, currencyID)
	var i models.WalletAddress
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.UserID,
		&i.CurrencyID,
		&i.Blockchain,
		&i.Address,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Dirty,
	)
	return &i, err
}

const getListByCurrencyWithAmount = `-- name: GetListByCurrencyWithAmount :one
select c.id, c.code, c.name, c.precision, c.is_fiat, c.blockchain, c.contract_address, c.withdrawal_min_balance, c.has_balance, c.status, c.sort_order, c.min_confirmation, c.created_at, c.updated_at, c.is_stablecoin, c.currency_label, c.token_label, array_agg(address)::varchar[] as addresses, sum(amount)::numeric as amount
from wallet_addresses wa
         inner join currencies c on c.id = wa.currency_id
WHERE wa.currency_id = $1
  AND wa.user_id = $2
  AND wa.amount > 0
  AND (COALESCE(array_length($3::uuid[], 1), 0) = 0 OR wa.id = ANY ($3::uuid[]))
  AND ($4::uuid[] IS NULL OR NOT wa.id = ANY ($4::uuid[]))
group by c.id
`

type GetListByCurrencyWithAmountParams struct {
	CurrID      string      `db:"curr_id" json:"curr_id"`
	UserID      uuid.UUID   `db:"user_id" json:"user_id"`
	Ids         []uuid.UUID `db:"ids" json:"ids"`
	ExcludedIds []uuid.UUID `db:"excluded_ids" json:"excluded_ids"`
}

type GetListByCurrencyWithAmountRow struct {
	Currency  models.Currency `db:"currency" json:"currency"`
	Addresses []string        `db:"addresses" json:"addresses"`
	Amount    decimal.Decimal `db:"amount" json:"amount"`
}

func (q *Queries) GetListByCurrencyWithAmount(ctx context.Context, arg GetListByCurrencyWithAmountParams) (*GetListByCurrencyWithAmountRow, error) {
	row := q.db.QueryRow(ctx, getListByCurrencyWithAmount,
		arg.CurrID,
		arg.UserID,
		arg.Ids,
		arg.ExcludedIds,
	)
	var i GetListByCurrencyWithAmountRow
	err := row.Scan(
		&i.Currency.ID,
		&i.Currency.Code,
		&i.Currency.Name,
		&i.Currency.Precision,
		&i.Currency.IsFiat,
		&i.Currency.Blockchain,
		&i.Currency.ContractAddress,
		&i.Currency.WithdrawalMinBalance,
		&i.Currency.HasBalance,
		&i.Currency.Status,
		&i.Currency.SortOrder,
		&i.Currency.MinConfirmation,
		&i.Currency.CreatedAt,
		&i.Currency.UpdatedAt,
		&i.Currency.IsStablecoin,
		&i.Currency.CurrencyLabel,
		&i.Currency.TokenLabel,
		&i.Addresses,
		&i.Amount,
	)
	return &i, err
}

const getPrefetchWalletAddressByUserID = `-- name: GetPrefetchWalletAddressByUserID :many
select withdrawal_wallets.id             as withdrawal_wallet_id,
       wallet_addresses.id, wallet_addresses.wallet_id, wallet_addresses.user_id, wallet_addresses.currency_id, wallet_addresses.blockchain, wallet_addresses.address, wallet_addresses.amount, wallet_addresses.created_at, wallet_addresses.updated_at, wallet_addresses.deleted_at, wallet_addresses.dirty,
       currencies.id, currencies.code, currencies.name, currencies.precision, currencies.is_fiat, currencies.blockchain, currencies.contract_address, currencies.withdrawal_min_balance, currencies.has_balance, currencies.status, currencies.sort_order, currencies.min_confirmation, currencies.created_at, currencies.updated_at, currencies.is_stablecoin, currencies.currency_label, currencies.token_label,
       (amount * exchange_rate)::decimal as amount_usd
from wallet_addresses
         left join currencies
                   on wallet_addresses.currency_id = currencies.id
         left join
     (SELECT unnest($2::text[])     AS currency_id,
             unnest($3::decimal[]) AS exchange_rate) rate
     on currencies.id = rate.currency_id
         left join withdrawal_wallets on wallet_addresses.currency_id = withdrawal_wallets.currency_id
    and wallet_addresses.user_id = withdrawal_wallets.user_id
where wallet_addresses.user_id = $1
  and wallet_addresses.amount > withdrawal_wallets.withdrawal_min_balance
  and (withdrawal_wallets.withdrawal_min_balance_usd is null or
       (wallet_addresses.amount * exchange_rate)::decimal > withdrawal_wallets.withdrawal_min_balance_usd::numeric)
  and wallet_addresses.address not in (select unnest(from_addresses)
                                       from transfers
                                       where user_id = $1
                                         and kind = 'from_address'
                                         and (transfers.stage = 'in_progress'
                                           or
                                              (transfers.stage = 'completed' and
                                               updated_at > (now() - interval '5 minutes'))
                                           or
                                              (transfers.stage = 'failed' and
                                               created_at > (now() - interval '30 minutes'))
                                           ))
  and withdrawal_wallets.withdrawal_enabled = 'enabled'
order by amount_usd desc
`

type GetPrefetchWalletAddressByUserIDParams struct {
	UserID       uuid.UUID         `db:"user_id" json:"user_id"`
	CurrencyIds  []string          `db:"currency_ids" json:"currency_ids"`
	CurrencyRate []decimal.Decimal `db:"currency_rate" json:"currency_rate"`
}

type GetPrefetchWalletAddressByUserIDRow struct {
	WithdrawalWalletID uuid.NullUUID        `db:"withdrawal_wallet_id" json:"withdrawal_wallet_id"`
	WalletAddress      models.WalletAddress `db:"wallet_address" json:"wallet_address"`
	Currency           models.Currency      `db:"currency" json:"currency"`
	AmountUsd          decimal.Decimal      `db:"amount_usd" json:"amount_usd"`
}

func (q *Queries) GetPrefetchWalletAddressByUserID(ctx context.Context, arg GetPrefetchWalletAddressByUserIDParams) ([]*GetPrefetchWalletAddressByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getPrefetchWalletAddressByUserID, arg.UserID, arg.CurrencyIds, arg.CurrencyRate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPrefetchWalletAddressByUserIDRow{}
	for rows.Next() {
		var i GetPrefetchWalletAddressByUserIDRow
		if err := rows.Scan(
			&i.WithdrawalWalletID,
			&i.WalletAddress.ID,
			&i.WalletAddress.WalletID,
			&i.WalletAddress.UserID,
			&i.WalletAddress.CurrencyID,
			&i.WalletAddress.Blockchain,
			&i.WalletAddress.Address,
			&i.WalletAddress.Amount,
			&i.WalletAddress.CreatedAt,
			&i.WalletAddress.UpdatedAt,
			&i.WalletAddress.DeletedAt,
			&i.WalletAddress.Dirty,
			&i.Currency.ID,
			&i.Currency.Code,
			&i.Currency.Name,
			&i.Currency.Precision,
			&i.Currency.IsFiat,
			&i.Currency.Blockchain,
			&i.Currency.ContractAddress,
			&i.Currency.WithdrawalMinBalance,
			&i.Currency.HasBalance,
			&i.Currency.Status,
			&i.Currency.SortOrder,
			&i.Currency.MinConfirmation,
			&i.Currency.CreatedAt,
			&i.Currency.UpdatedAt,
			&i.Currency.IsStablecoin,
			&i.Currency.CurrencyLabel,
			&i.Currency.TokenLabel,
			&i.AmountUsd,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletAddressesByAddress = `-- name: GetWalletAddressesByAddress :one
SELECT id, wallet_id, user_id, currency_id, blockchain, address, amount, created_at, updated_at, deleted_at, dirty
FROM wallet_addresses
WHERE deleted_at IS NULL
  AND wallet_id = $1
  and address = $2
  and currency_id = $3
limit 1
`

type GetWalletAddressesByAddressParams struct {
	WalletID   uuid.UUID `db:"wallet_id" json:"wallet_id"`
	Address    string    `db:"address" json:"address"`
	CurrencyID string    `db:"currency_id" json:"currency_id"`
}

func (q *Queries) GetWalletAddressesByAddress(ctx context.Context, arg GetWalletAddressesByAddressParams) (*models.WalletAddress, error) {
	row := q.db.QueryRow(ctx, getWalletAddressesByAddress, arg.WalletID, arg.Address, arg.CurrencyID)
	var i models.WalletAddress
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.UserID,
		&i.CurrencyID,
		&i.Blockchain,
		&i.Address,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Dirty,
	)
	return &i, err
}

const getWalletAddressesByUserID = `-- name: GetWalletAddressesByUserID :many
SELECT id, wallet_id, user_id, currency_id, blockchain, address, amount, created_at, updated_at, deleted_at, dirty
FROM wallet_addresses
WHERE user_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetWalletAddressesByUserID(ctx context.Context, userID uuid.UUID) ([]*models.WalletAddress, error) {
	rows, err := q.db.Query(ctx, getWalletAddressesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.WalletAddress{}
	for rows.Next() {
		var i models.WalletAddress
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.UserID,
			&i.CurrencyID,
			&i.Blockchain,
			&i.Address,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Dirty,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletAddressesByWalletId = `-- name: GetWalletAddressesByWalletId :many
SELECT id, wallet_id, user_id, currency_id, blockchain, address, amount, created_at, updated_at, deleted_at, dirty
FROM wallet_addresses
WHERE deleted_at IS NULL
  AND wallet_id = $1
`

func (q *Queries) GetWalletAddressesByWalletId(ctx context.Context, walletID uuid.UUID) ([]*models.WalletAddress, error) {
	rows, err := q.db.Query(ctx, getWalletAddressesByWalletId, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.WalletAddress{}
	for rows.Next() {
		var i models.WalletAddress
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.UserID,
			&i.CurrencyID,
			&i.Blockchain,
			&i.Address,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Dirty,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletAddressesTotalWithCurrencyID = `-- name: GetWalletAddressesTotalWithCurrencyID :many
SELECT amount::NUMERIC as balance, currencies.code
FROM wallet_addresses
         LEFT JOIN currencies ON wallet_addresses.currency_id = currencies.id
WHERE user_id = $1
  AND amount > 0
  AND deleted_at IS NULL
`

type GetWalletAddressesTotalWithCurrencyIDRow struct {
	Balance decimal.Decimal `db:"balance" json:"balance"`
	Code    pgtype.Text     `db:"code" json:"code"`
}

func (q *Queries) GetWalletAddressesTotalWithCurrencyID(ctx context.Context, userID uuid.UUID) ([]*GetWalletAddressesTotalWithCurrencyIDRow, error) {
	rows, err := q.db.Query(ctx, getWalletAddressesTotalWithCurrencyID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWalletAddressesTotalWithCurrencyIDRow{}
	for rows.Next() {
		var i GetWalletAddressesTotalWithCurrencyIDRow
		if err := rows.Scan(&i.Balance, &i.Code); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletsDataForRestoreByBlockchains = `-- name: GetWalletsDataForRestoreByBlockchains :many
SELECT wa.id, wa.wallet_id, wa.user_id, wa.currency_id, wa.blockchain, wa.address, wa.amount, wa.created_at, wa.updated_at, wa.deleted_at, wa.dirty, c.id, c.code, c.name, c.precision, c.is_fiat, c.blockchain, c.contract_address, c.withdrawal_min_balance, c.has_balance, c.status, c.sort_order, c.min_confirmation, c.created_at, c.updated_at, c.is_stablecoin, c.currency_label, c.token_label, s.id, s.user_id, s.name, s.site, s.currency_id, s.rate_source, s.return_url, s.success_url, s.rate_scale, s.status, s.minimal_payment, s.created_at, s.updated_at, s.deleted_at, s.public_payment_form_enabled
FROM wallet_addresses wa
         JOIN currencies c ON wa.currency_id = c.id
         JOIN wallets w ON wa.wallet_id = w.id
         JOIN stores s ON w.store_id = s.id
WHERE ($1::varchar[] IS NULL OR c.blockchain = ANY ($1::varchar[]))
`

type GetWalletsDataForRestoreByBlockchainsRow struct {
	WalletAddress models.WalletAddress `db:"wallet_address" json:"wallet_address"`
	Currency      models.Currency      `db:"currency" json:"currency"`
	Store         models.Store         `db:"store" json:"store"`
}

func (q *Queries) GetWalletsDataForRestoreByBlockchains(ctx context.Context, blockchains []string) ([]*GetWalletsDataForRestoreByBlockchainsRow, error) {
	rows, err := q.db.Query(ctx, getWalletsDataForRestoreByBlockchains, blockchains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWalletsDataForRestoreByBlockchainsRow{}
	for rows.Next() {
		var i GetWalletsDataForRestoreByBlockchainsRow
		if err := rows.Scan(
			&i.WalletAddress.ID,
			&i.WalletAddress.WalletID,
			&i.WalletAddress.UserID,
			&i.WalletAddress.CurrencyID,
			&i.WalletAddress.Blockchain,
			&i.WalletAddress.Address,
			&i.WalletAddress.Amount,
			&i.WalletAddress.CreatedAt,
			&i.WalletAddress.UpdatedAt,
			&i.WalletAddress.DeletedAt,
			&i.WalletAddress.Dirty,
			&i.Currency.ID,
			&i.Currency.Code,
			&i.Currency.Name,
			&i.Currency.Precision,
			&i.Currency.IsFiat,
			&i.Currency.Blockchain,
			&i.Currency.ContractAddress,
			&i.Currency.WithdrawalMinBalance,
			&i.Currency.HasBalance,
			&i.Currency.Status,
			&i.Currency.SortOrder,
			&i.Currency.MinConfirmation,
			&i.Currency.CreatedAt,
			&i.Currency.UpdatedAt,
			&i.Currency.IsStablecoin,
			&i.Currency.CurrencyLabel,
			&i.Currency.TokenLabel,
			&i.Store.ID,
			&i.Store.UserID,
			&i.Store.Name,
			&i.Store.Site,
			&i.Store.CurrencyID,
			&i.Store.RateSource,
			&i.Store.ReturnUrl,
			&i.Store.SuccessUrl,
			&i.Store.RateScale,
			&i.Store.Status,
			&i.Store.MinimalPayment,
			&i.Store.CreatedAt,
			&i.Store.UpdatedAt,
			&i.Store.DeletedAt,
			&i.Store.PublicPaymentFormEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isWalletExistsByAddress = `-- name: IsWalletExistsByAddress :one
SELECT EXISTS(SELECT id, wallet_id, user_id, currency_id, blockchain, address, amount, created_at, updated_at, deleted_at, dirty FROM wallet_addresses WHERE address = $1)
LIMIT 1
`

func (q *Queries) IsWalletExistsByAddress(ctx context.Context, address string) (bool, error) {
	row := q.db.QueryRow(ctx, isWalletExistsByAddress, address)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const markAddressDirty = `-- name: MarkAddressDirty :one
UPDATE wallet_addresses
SET updated_at=now(),
    dirty= true
WHERE address = $1
RETURNING id, wallet_id, user_id, currency_id, blockchain, address, amount, created_at, updated_at, deleted_at, dirty
`

func (q *Queries) MarkAddressDirty(ctx context.Context, address string) (*models.WalletAddress, error) {
	row := q.db.QueryRow(ctx, markAddressDirty, address)
	var i models.WalletAddress
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.UserID,
		&i.CurrencyID,
		&i.Blockchain,
		&i.Address,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Dirty,
	)
	return &i, err
}

const restoreByWallets = `-- name: RestoreByWallets :exec
UPDATE wallet_addresses
SET deleted_at = NULL
WHERE wallet_id = ANY ($1::uuid[])
`

func (q *Queries) RestoreByWallets(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, restoreByWallets, dollar_1)
	return err
}

const softDeleteByWallets = `-- name: SoftDeleteByWallets :exec
UPDATE wallet_addresses
SET deleted_at = now()
WHERE wallet_id = ANY ($1::uuid[])
`

func (q *Queries) SoftDeleteByWallets(ctx context.Context, dollar_1 []uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteByWallets, dollar_1)
	return err
}

const updateWalletBalance = `-- name: UpdateWalletBalance :exec
WITH balances as (SELECT SUM(
                                 CASE
                                     WHEN type = 'deposit' AND to_address = $1 THEN amount
                                     WHEN type = 'transfer' AND from_address = $1 THEN -amount
                                     ELSE 0
                                     END
                         )::numeric AS balance
                  FROM transactions
                  WHERE $1 IN (to_address, from_address)
                    and currency_id = $2
                  LIMIT 1)
UPDATE wallet_addresses wa
SET amount=COALESCE(b.balance, wa.amount),
    updated_at=now()
FROM balances b
WHERE wa.currency_id = $2
  AND wa.address = $1
`

func (q *Queries) UpdateWalletBalance(ctx context.Context, address string, currencyID string) error {
	_, err := q.db.Exec(ctx, updateWalletBalance, address, currencyID)
	return err
}

const updateWalletNativeTokenBalance = `-- name: UpdateWalletNativeTokenBalance :exec
WITH native_token_balance as (SELECT (SUM(CASE
                                              WHEN type = 'deposit' AND transactions.to_address = $1 THEN amount
                                              WHEN type = 'transfer' AND transactions.from_address = $1 THEN -amount
                                              ELSE 0
    END)
    - COALESCE((SELECT SUM(fee)
                FROM transactions
                WHERE type = 'transfer'
                  AND transactions.from_address = $1
                  AND transactions.blockchain = $3), 0))::numeric AS balance
                              FROM transactions
                              WHERE $1 IN (to_address, from_address)
                                AND transactions.currency_id = $2
                                AND transactions.blockchain = $3
                              LIMIT 1)
UPDATE wallet_addresses wa
SET amount=COALESCE(b.balance, wa.amount),
    updated_at=now()
FROM native_token_balance b
WHERE wa.currency_id = $2
  AND wa.address = $1
`

type UpdateWalletNativeTokenBalanceParams struct {
	Address    string `db:"address" json:"address"`
	CurrencyID string `db:"currency_id" json:"currency_id"`
	Blockchain string `db:"blockchain" json:"blockchain"`
}

func (q *Queries) UpdateWalletNativeTokenBalance(ctx context.Context, arg UpdateWalletNativeTokenBalanceParams) error {
	_, err := q.db.Exec(ctx, updateWalletNativeTokenBalance, arg.Address, arg.CurrencyID, arg.Blockchain)
	return err
}
