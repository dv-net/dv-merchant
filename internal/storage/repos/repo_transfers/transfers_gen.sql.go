// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transfers_gen.sql

package repo_transfers

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const create = `-- name: Create :one
INSERT INTO transfers (id, user_id, kind, currency_id, status, stage, amount, amount_usd, message, created_at, updated_at, blockchain, from_addresses, to_addresses, step, tx_hash)
	VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, now(), now(), $10, $11, $12, $13, $14)
	RETURNING id, number, user_id, kind, currency_id, status, stage, amount, amount_usd, message, created_at, updated_at, blockchain, from_addresses, to_addresses, step, tx_hash
`

type CreateParams struct {
	ID            uuid.UUID             `db:"id" json:"id"`
	UserID        uuid.UUID             `db:"user_id" json:"user_id"`
	Kind          models.TransferKind   `db:"kind" json:"kind"`
	CurrencyID    string                `db:"currency_id" json:"currency_id"`
	Status        models.TransferStatus `db:"status" json:"status"`
	Stage         models.TransferStage  `db:"stage" json:"stage"`
	Amount        decimal.Decimal       `db:"amount" json:"amount"`
	AmountUsd     decimal.Decimal       `db:"amount_usd" json:"amount_usd"`
	Message       *string               `db:"message" json:"message"`
	Blockchain    models.Blockchain     `db:"blockchain" json:"blockchain"`
	FromAddresses []string              `db:"from_addresses" json:"from_addresses"`
	ToAddresses   []string              `db:"to_addresses" json:"to_addresses"`
	Step          *string               `db:"step" json:"step"`
	TxHash        *string               `db:"tx_hash" json:"tx_hash"`
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (*models.Transfer, error) {
	row := q.db.QueryRow(ctx, create,
		arg.ID,
		arg.UserID,
		arg.Kind,
		arg.CurrencyID,
		arg.Status,
		arg.Stage,
		arg.Amount,
		arg.AmountUsd,
		arg.Message,
		arg.Blockchain,
		arg.FromAddresses,
		arg.ToAddresses,
		arg.Step,
		arg.TxHash,
	)
	var i models.Transfer
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.UserID,
		&i.Kind,
		&i.CurrencyID,
		&i.Status,
		&i.Stage,
		&i.Amount,
		&i.AmountUsd,
		&i.Message,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Blockchain,
		&i.FromAddresses,
		&i.ToAddresses,
		&i.Step,
		&i.TxHash,
	)
	return &i, err
}

const getAll = `-- name: GetAll :many
SELECT id, number, user_id, kind, currency_id, status, stage, amount, amount_usd, message, created_at, updated_at, blockchain, from_addresses, to_addresses, step, tx_hash FROM transfers ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type GetAllParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAll(ctx context.Context, arg GetAllParams) ([]*models.Transfer, error) {
	rows, err := q.db.Query(ctx, getAll, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Transfer{}
	for rows.Next() {
		var i models.Transfer
		if err := rows.Scan(
			&i.ID,
			&i.Number,
			&i.UserID,
			&i.Kind,
			&i.CurrencyID,
			&i.Status,
			&i.Stage,
			&i.Amount,
			&i.AmountUsd,
			&i.Message,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Blockchain,
			&i.FromAddresses,
			&i.ToAddresses,
			&i.Step,
			&i.TxHash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getById = `-- name: GetById :one
SELECT id, number, user_id, kind, currency_id, status, stage, amount, amount_usd, message, created_at, updated_at, blockchain, from_addresses, to_addresses, step, tx_hash FROM transfers WHERE id=$1 LIMIT 1
`

func (q *Queries) GetById(ctx context.Context, id uuid.UUID) (*models.Transfer, error) {
	row := q.db.QueryRow(ctx, getById, id)
	var i models.Transfer
	err := row.Scan(
		&i.ID,
		&i.Number,
		&i.UserID,
		&i.Kind,
		&i.CurrencyID,
		&i.Status,
		&i.Stage,
		&i.Amount,
		&i.AmountUsd,
		&i.Message,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Blockchain,
		&i.FromAddresses,
		&i.ToAddresses,
		&i.Step,
		&i.TxHash,
	)
	return &i, err
}
