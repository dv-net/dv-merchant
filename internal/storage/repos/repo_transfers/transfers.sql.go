// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transfers.sql

package repo_transfers

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
)

const isFailedTransferExistsByAddress = `-- name: IsFailedTransferExistsByAddress :one
SELECT EXISTS(SELECT 1
              FROM transfers
              where user_id = $1
                AND kind = 'transferFromAddress'
                AND $2 = ANY (from_addresses)
                AND currency_id = $3
                AND created_at > (NOW() - INTERVAL '20 minutes'))
`

type IsFailedTransferExistsByAddressParams struct {
	UserID        uuid.UUID `db:"user_id" json:"user_id"`
	FromAddresses []string  `db:"from_addresses" json:"from_addresses"`
	CurrencyID    string    `db:"currency_id" json:"currency_id"`
}

func (q *Queries) IsFailedTransferExistsByAddress(ctx context.Context, arg IsFailedTransferExistsByAddressParams) (bool, error) {
	row := q.db.QueryRow(ctx, isFailedTransferExistsByAddress, arg.UserID, arg.FromAddresses, arg.CurrencyID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateTransferStatus = `-- name: UpdateTransferStatus :exec
UPDATE transfers
SET status = $1,
    stage = $2,
    message = $3,
    step = $4,
    updated_at = now()
WHERE id = $5
`

type UpdateTransferStatusParams struct {
	Status  models.TransferStatus `db:"status" json:"status"`
	Stage   models.TransferStage  `db:"stage" json:"stage"`
	Message *string               `db:"message" json:"message"`
	Step    *string               `db:"step" json:"step"`
	ID      uuid.UUID             `db:"id" json:"id"`
}

func (q *Queries) UpdateTransferStatus(ctx context.Context, arg UpdateTransferStatusParams) error {
	_, err := q.db.Exec(ctx, updateTransferStatus,
		arg.Status,
		arg.Stage,
		arg.Message,
		arg.Step,
		arg.ID,
	)
	return err
}

const updateTxHash = `-- name: UpdateTxHash :exec
UPDATE transfers SET tx_hash = $2 WHERE id = $1 AND tx_hash is null
`

type UpdateTxHashParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	TxHash *string   `db:"tx_hash" json:"tx_hash"`
}

func (q *Queries) UpdateTxHash(ctx context.Context, arg UpdateTxHashParams) error {
	_, err := q.db.Exec(ctx, updateTxHash, arg.ID, arg.TxHash)
	return err
}
