// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package repo_transactions

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const calculateDepositStatistics = `-- name: CalculateDepositStatistics :many
WITH tx_filtered AS (SELECT id,
                            amount_usd,
                            currency_id,
                            date_trunc($1::text, (created_at AT TIME ZONE 'UTC') AT TIME ZONE
                                                                   $2::text) AS truncated_date
                     FROM transactions
                     WHERE type = 'deposit'
                       AND amount_usd >= 1
                       AND (created_at >=
                            ($3::timestamp AT TIME ZONE $2::text AT TIME ZONE 'UTC')
                         AND created_at <
                             ($4::timestamp AT TIME ZONE $2::text AT TIME ZONE 'UTC'))
                       AND ($5::uuid[] IS NULL OR store_id = ANY ($5::uuid[]))
                       AND ($6::varchar[] IS NULL OR
                            currency_id = ANY ($6::varchar[]))
                       AND user_id = $7::uuid
                       AND is_system = false),
     currency_stats AS (SELECT truncated_date,
                               currency_id,
                               COUNT(id)       AS currency_tx_count,
                               SUM(amount_usd) AS currency_sum_usd
                        FROM tx_filtered
                        GROUP BY truncated_date, currency_id),
     monthly_totals AS (SELECT truncated_date,
                               COUNT(id)       AS total_tx_count,
                               SUM(amount_usd) AS total_sum_usd
                        FROM tx_filtered
                        GROUP BY truncated_date)
SELECT mt.truncated_date::timestamp  AS date,
       mt.total_tx_count             AS tx_count,
       mt.total_sum_usd::numeric     AS sum,
       $1::varchar AS resolution,
       jsonb_object_agg(
               cs.currency_id,
               jsonb_build_object('tx_count', cs.currency_tx_count, 'sum_usd', cs.currency_sum_usd::numeric)
       )                             AS currency_stats
FROM monthly_totals mt
         LEFT JOIN currency_stats cs ON mt.truncated_date = cs.truncated_date
GROUP BY mt.truncated_date, mt.total_tx_count, mt.total_sum_usd
ORDER BY mt.truncated_date DESC
`

type CalculateDepositStatisticsParams struct {
	Resolution  string           `db:"resolution" json:"resolution"`
	Timezone    string           `db:"timezone" json:"timezone"`
	DateFrom    pgtype.Timestamp `db:"date_from" json:"date_from"`
	DateTo      pgtype.Timestamp `db:"date_to" json:"date_to"`
	StoreUuids  []uuid.UUID      `db:"store_uuids" json:"store_uuids"`
	CurrencyIds []string         `db:"currency_ids" json:"currency_ids"`
	UserID      uuid.UUID        `db:"user_id" json:"user_id"`
}

type CalculateDepositStatisticsRow struct {
	Date          pgtype.Timestamp `db:"date" json:"date"`
	TxCount       int64            `db:"tx_count" json:"tx_count"`
	Sum           decimal.Decimal  `db:"sum" json:"sum"`
	Resolution    string           `db:"resolution" json:"resolution"`
	CurrencyStats []byte           `db:"currency_stats" json:"currency_stats"`
}

func (q *Queries) CalculateDepositStatistics(ctx context.Context, arg CalculateDepositStatisticsParams) ([]*CalculateDepositStatisticsRow, error) {
	rows, err := q.db.Query(ctx, calculateDepositStatistics,
		arg.Resolution,
		arg.Timezone,
		arg.DateFrom,
		arg.DateTo,
		arg.StoreUuids,
		arg.CurrencyIds,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CalculateDepositStatisticsRow{}
	for rows.Next() {
		var i CalculateDepositStatisticsRow
		if err := rows.Scan(
			&i.Date,
			&i.TxCount,
			&i.Sum,
			&i.Resolution,
			&i.CurrencyStats,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const calculateDepositStatisticsTotal = `-- name: CalculateDepositStatisticsTotal :one
WITH currency_stats AS (SELECT currency_id,
                               COUNT(id)       AS currency_tx_count,
                               SUM(amount_usd) AS currency_sum_usd
                        FROM transactions
                        WHERE type = 'deposit'
                          AND amount_usd >= 1
                          AND created_at >=
                              ($2::timestamp AT TIME ZONE $1::text AT TIME ZONE 'UTC')
                          AND created_at <
                              ($3::timestamp AT TIME ZONE $1::text AT TIME ZONE 'UTC')
                          AND ($4::uuid[] IS NULL OR store_id = ANY ($4::uuid[]))
                          AND user_id = $5::uuid
                          AND is_system = false
                        GROUP BY currency_id),
     overall_stats AS (SELECT COUNT(id)       AS tx_count,
                              SUM(amount_usd) AS sum
                       FROM transactions
                       WHERE type = 'deposit'
                         AND amount_usd >= 1
                         AND created_at >=
                             ($2::timestamp AT TIME ZONE $1::text AT TIME ZONE 'UTC')
                         AND created_at <
                             ($3::timestamp AT TIME ZONE $1::text AT TIME ZONE 'UTC')
                         AND ($4::uuid[] IS NULL OR store_id = ANY ($4::uuid[]))
                         AND user_id = $5::uuid
                         AND is_system = false)
SELECT os.tx_count     as tx_count,
       os.sum::numeric as sum,
       jsonb_object_agg(
               cs.currency_id,
               jsonb_build_object(
                       'tx_count', cs.currency_tx_count,
                       'sum_usd', cs.currency_sum_usd::numeric
               )
       )               AS currency_stats
FROM overall_stats os,
     currency_stats cs
GROUP BY os.tx_count, os.sum
`

type CalculateDepositStatisticsTotalParams struct {
	Timezone   string           `db:"timezone" json:"timezone"`
	DateFrom   pgtype.Timestamp `db:"date_from" json:"date_from"`
	DateTo     pgtype.Timestamp `db:"date_to" json:"date_to"`
	StoreUuids []uuid.UUID      `db:"store_uuids" json:"store_uuids"`
	UserID     uuid.UUID        `db:"user_id" json:"user_id"`
}

type CalculateDepositStatisticsTotalRow struct {
	TxCount       int64           `db:"tx_count" json:"tx_count"`
	Sum           decimal.Decimal `db:"sum" json:"sum"`
	CurrencyStats []byte          `db:"currency_stats" json:"currency_stats"`
}

func (q *Queries) CalculateDepositStatisticsTotal(ctx context.Context, arg CalculateDepositStatisticsTotalParams) (*CalculateDepositStatisticsTotalRow, error) {
	row := q.db.QueryRow(ctx, calculateDepositStatisticsTotal,
		arg.Timezone,
		arg.DateFrom,
		arg.DateTo,
		arg.StoreUuids,
		arg.UserID,
	)
	var i CalculateDepositStatisticsTotalRow
	err := row.Scan(&i.TxCount, &i.Sum, &i.CurrencyStats)
	return &i, err
}

const findLastWalletTransactions = `-- name: FindLastWalletTransactions :many
WITH tx AS ((SELECT true as is_confirmed,
                    t.wallet_id,
                    t.currency_id,
                    t.tx_hash,
                    t.amount,
                    t.amount_usd,
                    t.type,
                    t.created_at
             FROM transactions t
             WHERE t.wallet_id = $1
               AND t.amount_usd >= 1
               AND t.type = $2
             ORDER BY created_at_index DESC
             LIMIT $3)
            UNION
            (SELECT false as is_confirmed,
                    ut.wallet_id,
                    ut.currency_id,
                    ut.tx_hash,
                    ut.amount,
                    ut.amount_usd,
                    ut.type,
                    ut.created_at
             FROM unconfirmed_transactions ut
             WHERE ut.wallet_id = $1
               AND ut.type = $2
               AND ut.amount_usd >= 1
               AND NOT EXISTS (SELECT 1
                               FROM transactions t2
                               WHERE t2.tx_hash = ut.tx_hash
                                 AND t2.currency_id = ut.currency_id
                                 AND t2.bc_uniq_key = ut.bc_uniq_key)
             ORDER BY created_at DESC
             LIMIT $3)
            LIMIT $3)
SELECT tx.is_confirmed, tx.wallet_id, tx.currency_id, tx.tx_hash, tx.amount, tx.amount_usd, tx.type, tx.created_at,
       c.id as curr_code
FROM tx
         INNER JOIN currencies c on c.id = tx.currency_id
ORDER BY tx.created_at DESC
LIMIT $3
`

type FindLastWalletTransactionsParams struct {
	WalletID uuid.NullUUID           `db:"wallet_id" json:"wallet_id"`
	Type     models.TransactionsType `db:"type" json:"type"`
	Limit    int32                   `db:"limit" json:"limit"`
}

type FindLastWalletTransactionsRow struct {
	IsConfirmed bool                `db:"is_confirmed" json:"is_confirmed"`
	WalletID    uuid.NullUUID       `db:"wallet_id" json:"wallet_id"`
	CurrencyID  string              `db:"currency_id" json:"currency_id"`
	TxHash      string              `db:"tx_hash" json:"tx_hash"`
	Amount      decimal.Decimal     `db:"amount" json:"amount"`
	AmountUsd   decimal.NullDecimal `db:"amount_usd" json:"amount_usd"`
	Type        string              `db:"type" json:"type"`
	CreatedAt   pgtype.Timestamp    `db:"created_at" json:"created_at"`
	CurrCode    string              `db:"curr_code" json:"curr_code"`
}

func (q *Queries) FindLastWalletTransactions(ctx context.Context, arg FindLastWalletTransactionsParams) ([]*FindLastWalletTransactionsRow, error) {
	rows, err := q.db.Query(ctx, findLastWalletTransactions, arg.WalletID, arg.Type, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*FindLastWalletTransactionsRow{}
	for rows.Next() {
		var i FindLastWalletTransactionsRow
		if err := rows.Scan(
			&i.IsConfirmed,
			&i.WalletID,
			&i.CurrencyID,
			&i.TxHash,
			&i.Amount,
			&i.AmountUsd,
			&i.Type,
			&i.CreatedAt,
			&i.CurrCode,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findTransactionByHashAndUserID = `-- name: FindTransactionByHashAndUserID :one
WITH tx AS ((SELECT t.id,
                    true         as is_confirmed,
                    t.user_id,
                    t.store_id,
                    t.receipt_id as receipt_id,
                    t.wallet_id,
                    t.currency_id,
                    t.bc_uniq_key,
                    t.blockchain as blockchain,
                    t.tx_hash,
                    t.from_address,
                    t.to_address,
                    t.amount,
                    t.amount_usd,
                    t.fee        as fee,
                    t.type,
                    t.network_created_at,
                    t.created_at
             FROM transactions t
             where t.tx_hash = $1
               AND t.user_id = $2)
            UNION
            (SELECT ut.id,
                    false as is_confirmed,
                    ut.user_id,
                    ut.store_id,
                    null  as receipt_id,
                    ut.wallet_id,
                    ut.currency_id,
                    ut.bc_uniq_key,
                    ut.blockchain,
                    ut.tx_hash,
                    ut.from_address,
                    ut.to_address,
                    ut.amount,
                    ut.amount_usd,
                    0     as fee,
                    ut.type,
                    ut.network_created_at,
                    ut.created_at
             FROM unconfirmed_transactions ut
             where ut.tx_hash = $1
               AND ut.user_id = $2)
            LIMIT 1)
SELECT tx.id, tx.is_confirmed, tx.user_id, tx.store_id, tx.receipt_id, tx.wallet_id, tx.currency_id, tx.bc_uniq_key, tx.blockchain, tx.tx_hash, tx.from_address, tx.to_address, tx.amount, tx.amount_usd, tx.fee, tx.type, tx.network_created_at, tx.created_at,
       w.id                as wallet_id,
       w.store_id          as wallet_store_id,
       w.store_external_id as store_external_id,
       w.created_at        as wallet_created_at,
       w.updated_at        as wallet_updated_at,
       c.code              as currency_code,
       c.blockchain        as currency_blockchain
FROM tx
         INNER JOIN wallets w on w.id = tx.wallet_id
         INNER JOIN currencies c on c.id = tx.currency_id
LIMIT 1
`

type FindTransactionByHashAndUserIDParams struct {
	TxHash string    `db:"tx_hash" json:"tx_hash"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

type FindTransactionByHashAndUserIDRow struct {
	ID                 uuid.UUID           `db:"id" json:"id"`
	IsConfirmed        bool                `db:"is_confirmed" json:"is_confirmed"`
	UserID             uuid.UUID           `db:"user_id" json:"user_id"`
	StoreID            uuid.NullUUID       `db:"store_id" json:"store_id"`
	ReceiptID          uuid.NullUUID       `db:"receipt_id" json:"receipt_id"`
	WalletID           uuid.NullUUID       `db:"wallet_id" json:"wallet_id"`
	CurrencyID         string              `db:"currency_id" json:"currency_id"`
	BcUniqKey          pgtype.Text         `db:"bc_uniq_key" json:"bc_uniq_key"`
	Blockchain         string              `db:"blockchain" json:"blockchain"`
	TxHash             string              `db:"tx_hash" json:"tx_hash"`
	FromAddress        pgtype.Text         `db:"from_address" json:"from_address"`
	ToAddress          string              `db:"to_address" json:"to_address"`
	Amount             decimal.Decimal     `db:"amount" json:"amount"`
	AmountUsd          decimal.NullDecimal `db:"amount_usd" json:"amount_usd"`
	Fee                decimal.Decimal     `db:"fee" json:"fee"`
	Type               string              `db:"type" json:"type"`
	NetworkCreatedAt   pgtype.Timestamp    `db:"network_created_at" json:"network_created_at"`
	CreatedAt          pgtype.Timestamp    `db:"created_at" json:"created_at"`
	WalletID_2         uuid.UUID           `db:"wallet_id_2" json:"wallet_id_2"`
	WalletStoreID      uuid.UUID           `db:"wallet_store_id" json:"wallet_store_id"`
	StoreExternalID    string              `db:"store_external_id" json:"store_external_id"`
	WalletCreatedAt    pgtype.Timestamp    `db:"wallet_created_at" json:"wallet_created_at"`
	WalletUpdatedAt    pgtype.Timestamp    `db:"wallet_updated_at" json:"wallet_updated_at"`
	CurrencyCode       string              `db:"currency_code" json:"currency_code"`
	CurrencyBlockchain *models.Blockchain  `db:"currency_blockchain" json:"currency_blockchain"`
}

func (q *Queries) FindTransactionByHashAndUserID(ctx context.Context, arg FindTransactionByHashAndUserIDParams) (*FindTransactionByHashAndUserIDRow, error) {
	row := q.db.QueryRow(ctx, findTransactionByHashAndUserID, arg.TxHash, arg.UserID)
	var i FindTransactionByHashAndUserIDRow
	err := row.Scan(
		&i.ID,
		&i.IsConfirmed,
		&i.UserID,
		&i.StoreID,
		&i.ReceiptID,
		&i.WalletID,
		&i.CurrencyID,
		&i.BcUniqKey,
		&i.Blockchain,
		&i.TxHash,
		&i.FromAddress,
		&i.ToAddress,
		&i.Amount,
		&i.AmountUsd,
		&i.Fee,
		&i.Type,
		&i.NetworkCreatedAt,
		&i.CreatedAt,
		&i.WalletID_2,
		&i.WalletStoreID,
		&i.StoreExternalID,
		&i.WalletCreatedAt,
		&i.WalletUpdatedAt,
		&i.CurrencyCode,
		&i.CurrencyBlockchain,
	)
	return &i, err
}

const getAddressBalance = `-- name: GetAddressBalance :one
SELECT SUM(
               CASE
                   WHEN type = 'deposit' AND to_address = $1 THEN amount
                   WHEN type = 'transfer' AND from_address = $1 THEN -amount
                   ELSE 0
                   END)::numeric AS balance
FROM transactions
WHERE $1 IN (to_address, from_address)
  and currency_id = $2
LIMIT 1
`

type GetAddressBalanceParams struct {
	ToAddress  string `db:"to_address" json:"to_address"`
	CurrencyID string `db:"currency_id" json:"currency_id"`
}

func (q *Queries) GetAddressBalance(ctx context.Context, arg GetAddressBalanceParams) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, getAddressBalance, arg.ToAddress, arg.CurrencyID)
	var balance decimal.Decimal
	err := row.Scan(&balance)
	return balance, err
}

const getBalanceNativeToken = `-- name: GetBalanceNativeToken :one
SELECT (SUM(CASE
                WHEN type = 'deposit' AND transactions.to_address = $1 THEN amount
                WHEN type = 'transfer' AND transactions.from_address = $1 THEN -amount
                ELSE 0
    END)
    - COALESCE((SELECT SUM(fee)
                FROM transactions
                WHERE type = 'transfer'
                  AND transactions.from_address = $1
                  AND transactions.blockchain = $3), 0))::numeric AS balance

FROM transactions
WHERE $1 IN (to_address, from_address)
  AND transactions.currency_id = $2
  AND transactions.blockchain = $3
LIMIT 1
`

type GetBalanceNativeTokenParams struct {
	ToAddress  string            `db:"to_address" json:"to_address"`
	CurrencyID string            `db:"currency_id" json:"currency_id"`
	Blockchain models.Blockchain `db:"blockchain" json:"blockchain"`
}

func (q *Queries) GetBalanceNativeToken(ctx context.Context, arg GetBalanceNativeTokenParams) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, getBalanceNativeToken, arg.ToAddress, arg.CurrencyID, arg.Blockchain)
	var balance decimal.Decimal
	err := row.Scan(&balance)
	return balance, err
}

const getExistingWithdrawalAddress = `-- name: GetExistingWithdrawalAddress :one
SELECT coalesce(to_address, '')::varchar
FROM transactions
WHERE from_address = $1::varchar
  AND to_address = ANY ($2::varchar[])
  AND type = 'transfer'
LIMIT 1
`

type GetExistingWithdrawalAddressParams struct {
	FromAddr          string   `db:"from_addr" json:"from_addr"`
	WithdrawAddresses []string `db:"withdraw_addresses" json:"withdraw_addresses"`
}

func (q *Queries) GetExistingWithdrawalAddress(ctx context.Context, arg GetExistingWithdrawalAddressParams) (string, error) {
	row := q.db.QueryRow(ctx, getExistingWithdrawalAddress, arg.FromAddr, arg.WithdrawAddresses)
	var column_1 string
	err := row.Scan(&column_1)
	return column_1, err
}

const getLastByHashAndBlockchain = `-- name: GetLastByHashAndBlockchain :one
SELECT id, user_id, store_id, receipt_id, wallet_id, currency_id, blockchain, tx_hash, bc_uniq_key, type, from_address, to_address, amount, amount_usd, fee, withdrawal_is_manual, network_created_at, created_at, updated_at, created_at_index, is_system
FROM transactions
WHERE tx_hash = $1
  AND blockchain = $2
ORDER BY created_at_index DESC
LIMIT 1
`

type GetLastByHashAndBlockchainParams struct {
	TxHash     string            `db:"tx_hash" json:"tx_hash"`
	Blockchain models.Blockchain `db:"blockchain" json:"blockchain"`
}

func (q *Queries) GetLastByHashAndBlockchain(ctx context.Context, arg GetLastByHashAndBlockchainParams) (*models.Transaction, error) {
	row := q.db.QueryRow(ctx, getLastByHashAndBlockchain, arg.TxHash, arg.Blockchain)
	var i models.Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StoreID,
		&i.ReceiptID,
		&i.WalletID,
		&i.CurrencyID,
		&i.Blockchain,
		&i.TxHash,
		&i.BcUniqKey,
		&i.Type,
		&i.FromAddress,
		&i.ToAddress,
		&i.Amount,
		&i.AmountUsd,
		&i.Fee,
		&i.WithdrawalIsManual,
		&i.NetworkCreatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedAtIndex,
		&i.IsSystem,
	)
	return &i, err
}

const getTransactionByHashAndBcUniqKey = `-- name: GetTransactionByHashAndBcUniqKey :one
SELECT id, user_id, store_id, receipt_id, wallet_id, currency_id, blockchain, tx_hash, bc_uniq_key, type, from_address, to_address, amount, amount_usd, fee, withdrawal_is_manual, network_created_at, created_at, updated_at, created_at_index, is_system
FROM transactions
WHERE tx_hash = $1
  and bc_uniq_key = $2
LIMIT 1
`

type GetTransactionByHashAndBcUniqKeyParams struct {
	TxHash    string  `db:"tx_hash" json:"tx_hash"`
	BcUniqKey *string `db:"bc_uniq_key" json:"bc_uniq_key"`
}

func (q *Queries) GetTransactionByHashAndBcUniqKey(ctx context.Context, arg GetTransactionByHashAndBcUniqKeyParams) (*models.Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByHashAndBcUniqKey, arg.TxHash, arg.BcUniqKey)
	var i models.Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.StoreID,
		&i.ReceiptID,
		&i.WalletID,
		&i.CurrencyID,
		&i.Blockchain,
		&i.TxHash,
		&i.BcUniqKey,
		&i.Type,
		&i.FromAddress,
		&i.ToAddress,
		&i.Amount,
		&i.AmountUsd,
		&i.Fee,
		&i.WithdrawalIsManual,
		&i.NetworkCreatedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CreatedAtIndex,
		&i.IsSystem,
	)
	return &i, err
}

const getTransactionsByStoreAndType = `-- name: GetTransactionsByStoreAndType :many
SELECT id, user_id, store_id, receipt_id, wallet_id, currency_id, blockchain, tx_hash, bc_uniq_key, type, from_address, to_address, amount, amount_usd, fee, withdrawal_is_manual, network_created_at, created_at, updated_at, created_at_index, is_system
FROM transactions
WHERE store_id = $1
  and type = $2
ORDER BY created_at_index DESC
LIMIT $3 OFFSET $4
`

type GetTransactionsByStoreAndTypeParams struct {
	StoreID uuid.NullUUID           `db:"store_id" json:"store_id"`
	Type    models.TransactionsType `db:"type" json:"type"`
	Limit   int32                   `db:"limit" json:"limit"`
	Offset  int32                   `db:"offset" json:"offset"`
}

func (q *Queries) GetTransactionsByStoreAndType(ctx context.Context, arg GetTransactionsByStoreAndTypeParams) ([]*models.Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByStoreAndType,
		arg.StoreID,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Transaction{}
	for rows.Next() {
		var i models.Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StoreID,
			&i.ReceiptID,
			&i.WalletID,
			&i.CurrencyID,
			&i.Blockchain,
			&i.TxHash,
			&i.BcUniqKey,
			&i.Type,
			&i.FromAddress,
			&i.ToAddress,
			&i.Amount,
			&i.AmountUsd,
			&i.Fee,
			&i.WithdrawalIsManual,
			&i.NetworkCreatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedAtIndex,
			&i.IsSystem,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByStoreId = `-- name: GetTransactionsByStoreId :many
SELECT id, user_id, store_id, receipt_id, wallet_id, currency_id, blockchain, tx_hash, bc_uniq_key, type, from_address, to_address, amount, amount_usd, fee, withdrawal_is_manual, network_created_at, created_at, updated_at, created_at_index, is_system
FROM transactions
WHERE store_id = $1
ORDER BY created_at_index DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByStoreIdParams struct {
	StoreID uuid.NullUUID `db:"store_id" json:"store_id"`
	Limit   int32         `db:"limit" json:"limit"`
	Offset  int32         `db:"offset" json:"offset"`
}

func (q *Queries) GetTransactionsByStoreId(ctx context.Context, arg GetTransactionsByStoreIdParams) ([]*models.Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByStoreId, arg.StoreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Transaction{}
	for rows.Next() {
		var i models.Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StoreID,
			&i.ReceiptID,
			&i.WalletID,
			&i.CurrencyID,
			&i.Blockchain,
			&i.TxHash,
			&i.BcUniqKey,
			&i.Type,
			&i.FromAddress,
			&i.ToAddress,
			&i.Amount,
			&i.AmountUsd,
			&i.Fee,
			&i.WithdrawalIsManual,
			&i.NetworkCreatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedAtIndex,
			&i.IsSystem,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByUserId = `-- name: GetTransactionsByUserId :many
SELECT id, user_id, store_id, receipt_id, wallet_id, currency_id, blockchain, tx_hash, bc_uniq_key, type, from_address, to_address, amount, amount_usd, fee, withdrawal_is_manual, network_created_at, created_at, updated_at, created_at_index, is_system
FROM transactions
WHERE user_id = $1
ORDER BY created_at_index DESC
LIMIT $2 OFFSET $3
`

type GetTransactionsByUserIdParams struct {
	UserID uuid.UUID `db:"user_id" json:"user_id"`
	Limit  int32     `db:"limit" json:"limit"`
	Offset int32     `db:"offset" json:"offset"`
}

func (q *Queries) GetTransactionsByUserId(ctx context.Context, arg GetTransactionsByUserIdParams) ([]*models.Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByUserId, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Transaction{}
	for rows.Next() {
		var i models.Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StoreID,
			&i.ReceiptID,
			&i.WalletID,
			&i.CurrencyID,
			&i.Blockchain,
			&i.TxHash,
			&i.BcUniqKey,
			&i.Type,
			&i.FromAddress,
			&i.ToAddress,
			&i.Amount,
			&i.AmountUsd,
			&i.Fee,
			&i.WithdrawalIsManual,
			&i.NetworkCreatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedAtIndex,
			&i.IsSystem,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWalletTransactions = `-- name: GetWalletTransactions :many
SELECT id, user_id, store_id, receipt_id, wallet_id, currency_id, blockchain, tx_hash, bc_uniq_key, type, from_address, to_address, amount, amount_usd, fee, withdrawal_is_manual, network_created_at, created_at, updated_at, created_at_index, is_system
FROM transactions t
WHERE t.wallet_id = $1
  AND t.to_address = $2
ORDER BY network_created_at DESC
LIMIT 500
`

type GetWalletTransactionsParams struct {
	WalletID  uuid.NullUUID `db:"wallet_id" json:"wallet_id"`
	ToAddress string        `db:"to_address" json:"to_address"`
}

func (q *Queries) GetWalletTransactions(ctx context.Context, arg GetWalletTransactionsParams) ([]*models.Transaction, error) {
	rows, err := q.db.Query(ctx, getWalletTransactions, arg.WalletID, arg.ToAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Transaction{}
	for rows.Next() {
		var i models.Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.StoreID,
			&i.ReceiptID,
			&i.WalletID,
			&i.CurrencyID,
			&i.Blockchain,
			&i.TxHash,
			&i.BcUniqKey,
			&i.Type,
			&i.FromAddress,
			&i.ToAddress,
			&i.Amount,
			&i.AmountUsd,
			&i.Fee,
			&i.WithdrawalIsManual,
			&i.NetworkCreatedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedAtIndex,
			&i.IsSystem,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
