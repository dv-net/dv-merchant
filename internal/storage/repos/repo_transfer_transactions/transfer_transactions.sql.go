// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transfer_transactions.sql

package repo_transfer_transactions

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const calculateTransfersExpense = `-- name: CalculateTransfersExpense :many
SELECT COUNT(DISTINCT t.id)                                                                 AS transfers_count,
       SUM(tt.native_token_fee)::numeric                                                    AS total_trx_fee,
       SUM(tt.bandwidth_amount)::numeric                                                    AS total_bandwidth,
       SUM(tt.energy_amount)::numeric                                                       AS total_energy,
       DATE_TRUNC($1::varchar, tt.created_at AT TIME ZONE $2::varchar)::timestamp AS day
FROM transfer_transactions tt
         INNER JOIN transfers t ON tt.transfer_id = t.id AND t.user_id = $3::uuid
         INNER JOIN currencies c ON t.currency_id = c.id AND c.blockchain = $4
    AND tt.created_at >= ($5::timestamp AT TIME ZONE $2::varchar)
    AND tt.created_at < ($6::timestamp AT TIME ZONE $2::varchar)
    AND tt.tx_type = ANY ($7::varchar[])
GROUP BY DATE_TRUNC($1::varchar, tt.created_at AT TIME ZONE $2::varchar)
ORDER BY day
`

type CalculateTransfersExpenseParams struct {
	Resolution string             `db:"resolution" json:"resolution"`
	Timezone   string             `db:"timezone" json:"timezone"`
	UserID     uuid.UUID          `db:"user_id" json:"user_id"`
	Blockchain *models.Blockchain `db:"blockchain" json:"blockchain"`
	DateFrom   pgtype.Timestamp   `db:"date_from" json:"date_from"`
	DateTo     pgtype.Timestamp   `db:"date_to" json:"date_to"`
	TxTypes    []string           `db:"tx_types" json:"tx_types"`
}

type CalculateTransfersExpenseRow struct {
	TransfersCount int64            `db:"transfers_count" json:"transfers_count"`
	TotalTrxFee    decimal.Decimal  `db:"total_trx_fee" json:"total_trx_fee"`
	TotalBandwidth decimal.Decimal  `db:"total_bandwidth" json:"total_bandwidth"`
	TotalEnergy    decimal.Decimal  `db:"total_energy" json:"total_energy"`
	Day            pgtype.Timestamp `db:"day" json:"day"`
}

func (q *Queries) CalculateTransfersExpense(ctx context.Context, arg CalculateTransfersExpenseParams) ([]*CalculateTransfersExpenseRow, error) {
	rows, err := q.db.Query(ctx, calculateTransfersExpense,
		arg.Resolution,
		arg.Timezone,
		arg.UserID,
		arg.Blockchain,
		arg.DateFrom,
		arg.DateTo,
		arg.TxTypes,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CalculateTransfersExpenseRow{}
	for rows.Next() {
		var i CalculateTransfersExpenseRow
		if err := rows.Scan(
			&i.TransfersCount,
			&i.TotalTrxFee,
			&i.TotalBandwidth,
			&i.TotalEnergy,
			&i.Day,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
