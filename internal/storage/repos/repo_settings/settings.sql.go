// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: settings.sql

package repo_settings

import (
	"context"
	"github.com/dv-net/dv-merchant/internal/models"

	"github.com/google/uuid"
)

const deleteByNameAndModelID = `-- name: DeleteByNameAndModelID :exec
DELETE FROM settings WHERE name=$1 AND model_id=$2
`

type DeleteByNameAndModelIDParams struct {
	Name    string        `db:"name" json:"name"`
	ModelID uuid.NullUUID `db:"model_id" json:"model_id"`
}

func (q *Queries) DeleteByNameAndModelID(ctx context.Context, arg DeleteByNameAndModelIDParams) error {
	_, err := q.db.Exec(ctx, deleteByNameAndModelID, arg.Name, arg.ModelID)
	return err
}

const deleteRootByName = `-- name: DeleteRootByName :exec
DELETE FROM settings WHERE name=$1
`

func (q *Queries) DeleteRootByName(ctx context.Context, name string) error {
	_, err := q.db.Exec(ctx, deleteRootByName, name)
	return err
}

const getAllByModel = `-- name: GetAllByModel :many
SELECT id, model_id, model_type, name, value, created_at, updated_at, is_mutable
FROM settings
WHERE model_id = $1
  and model_type = $2
`

type GetAllByModelParams struct {
	ModelID   uuid.NullUUID `db:"model_id" json:"model_id"`
	ModelType *string       `db:"model_type" json:"model_type"`
}

func (q *Queries) GetAllByModel(ctx context.Context, arg GetAllByModelParams) ([]*models.Setting, error) {
	rows, err := q.db.Query(ctx, getAllByModel, arg.ModelID, arg.ModelType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Setting{}
	for rows.Next() {
		var i models.Setting
		if err := rows.Scan(
			&i.ID,
			&i.ModelID,
			&i.ModelType,
			&i.Name,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMutable,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRootSettings = `-- name: GetAllRootSettings :many
SELECT id, model_id, model_type, name, value, created_at, updated_at, is_mutable
FROM settings
WHERE model_id is null
  and model_type is null
`

func (q *Queries) GetAllRootSettings(ctx context.Context) ([]*models.Setting, error) {
	rows, err := q.db.Query(ctx, getAllRootSettings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Setting{}
	for rows.Next() {
		var i models.Setting
		if err := rows.Scan(
			&i.ID,
			&i.ModelID,
			&i.ModelType,
			&i.Name,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMutable,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByModel = `-- name: GetByModel :one
SELECT id, model_id, model_type, name, value, created_at, updated_at, is_mutable
FROM settings
WHERE name = $1
  and model_id = $2
  and model_type = $3
LIMIT 1
`

type GetByModelParams struct {
	Name      string        `db:"name" json:"name"`
	ModelID   uuid.NullUUID `db:"model_id" json:"model_id"`
	ModelType *string       `db:"model_type" json:"model_type"`
}

func (q *Queries) GetByModel(ctx context.Context, arg GetByModelParams) (*models.Setting, error) {
	row := q.db.QueryRow(ctx, getByModel, arg.Name, arg.ModelID, arg.ModelType)
	var i models.Setting
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.ModelType,
		&i.Name,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMutable,
	)
	return &i, err
}

const getByName = `-- name: GetByName :one
SELECT id, model_id, model_type, name, value, created_at, updated_at, is_mutable
FROM settings
WHERE name = $1
  and model_id is null
  and model_type is null
LIMIT 1
`

func (q *Queries) GetByName(ctx context.Context, name string) (*models.Setting, error) {
	row := q.db.QueryRow(ctx, getByName, name)
	var i models.Setting
	err := row.Scan(
		&i.ID,
		&i.ModelID,
		&i.ModelType,
		&i.Name,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsMutable,
	)
	return &i, err
}

const getByNames = `-- name: GetByNames :many
SELECT id, model_id, model_type, name, value, created_at, updated_at, is_mutable
FROM settings
WHERE name = ANY ($1::varchar[])
  and model_id is null
`

func (q *Queries) GetByNames(ctx context.Context, settingNames []string) ([]*models.Setting, error) {
	rows, err := q.db.Query(ctx, getByNames, settingNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Setting{}
	for rows.Next() {
		var i models.Setting
		if err := rows.Scan(
			&i.ID,
			&i.ModelID,
			&i.ModelType,
			&i.Name,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMutable,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
