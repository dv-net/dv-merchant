// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: aml_supported_assets.sql

package repo_aml_supported_assets

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
)

const getAllBySlug = `-- name: GetAllBySlug :many
SELECT c.id, c.code, c.name, c.precision, c.is_fiat, c.blockchain, c.contract_address, c.withdrawal_min_balance, c.has_balance, c.status, c.sort_order, c.min_confirmation, c.created_at, c.updated_at, c.is_stablecoin, c.currency_label, c.token_label, c.is_native, c.is_new_store_default
FROM aml_supported_assets ass
         INNER JOIN currencies c on c.id = ass.currency_id
WHERE service_slug = $1
`

type GetAllBySlugRow struct {
	Currency models.Currency `db:"currency" json:"currency"`
}

func (q *Queries) GetAllBySlug(ctx context.Context, serviceSlug models.AMLSlug) ([]*GetAllBySlugRow, error) {
	rows, err := q.db.Query(ctx, getAllBySlug, serviceSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllBySlugRow{}
	for rows.Next() {
		var i GetAllBySlugRow
		if err := rows.Scan(
			&i.Currency.ID,
			&i.Currency.Code,
			&i.Currency.Name,
			&i.Currency.Precision,
			&i.Currency.IsFiat,
			&i.Currency.Blockchain,
			&i.Currency.ContractAddress,
			&i.Currency.WithdrawalMinBalance,
			&i.Currency.HasBalance,
			&i.Currency.Status,
			&i.Currency.SortOrder,
			&i.Currency.MinConfirmation,
			&i.Currency.CreatedAt,
			&i.Currency.UpdatedAt,
			&i.Currency.IsStablecoin,
			&i.Currency.CurrencyLabel,
			&i.Currency.TokenLabel,
			&i.Currency.IsNative,
			&i.Currency.IsNewStoreDefault,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBySlugAndCurrencyID = `-- name: GetBySlugAndCurrencyID :one
SELECT c.id, c.code, c.name, c.precision, c.is_fiat, c.blockchain, c.contract_address, c.withdrawal_min_balance, c.has_balance, c.status, c.sort_order, c.min_confirmation, c.created_at, c.updated_at, c.is_stablecoin, c.currency_label, c.token_label, c.is_native, c.is_new_store_default, ass.service_slug, ass.currency_id, ass.asset_identity, ass.blockchain_name
FROM aml_supported_assets ass
         INNER JOIN currencies c on c.id = ass.currency_id
WHERE currency_id = $1
  AND service_slug = $2
LIMIT 1
`

type GetBySlugAndCurrencyIDRow struct {
	Currency          models.Currency          `db:"currency" json:"currency"`
	AmlSupportedAsset models.AmlSupportedAsset `db:"aml_supported_asset" json:"aml_supported_asset"`
}

func (q *Queries) GetBySlugAndCurrencyID(ctx context.Context, currencyID string, serviceSlug models.AMLSlug) (*GetBySlugAndCurrencyIDRow, error) {
	row := q.db.QueryRow(ctx, getBySlugAndCurrencyID, currencyID, serviceSlug)
	var i GetBySlugAndCurrencyIDRow
	err := row.Scan(
		&i.Currency.ID,
		&i.Currency.Code,
		&i.Currency.Name,
		&i.Currency.Precision,
		&i.Currency.IsFiat,
		&i.Currency.Blockchain,
		&i.Currency.ContractAddress,
		&i.Currency.WithdrawalMinBalance,
		&i.Currency.HasBalance,
		&i.Currency.Status,
		&i.Currency.SortOrder,
		&i.Currency.MinConfirmation,
		&i.Currency.CreatedAt,
		&i.Currency.UpdatedAt,
		&i.Currency.IsStablecoin,
		&i.Currency.CurrencyLabel,
		&i.Currency.TokenLabel,
		&i.Currency.IsNative,
		&i.Currency.IsNewStoreDefault,
		&i.AmlSupportedAsset.ServiceSlug,
		&i.AmlSupportedAsset.CurrencyID,
		&i.AmlSupportedAsset.AssetIdentity,
		&i.AmlSupportedAsset.BlockchainName,
	)
	return &i, err
}
