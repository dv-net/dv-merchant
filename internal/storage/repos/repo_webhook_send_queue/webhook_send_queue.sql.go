// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: webhook_send_queue.sql

package repo_webhook_send_queue

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const delete = `-- name: Delete :exec
DELETE
FROM webhook_send_queue
WHERE id = $1
`

func (q *Queries) Delete(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, delete, id)
	return err
}

const getQueuedWebhooks = `-- name: GetQueuedWebhooks :many
SELECT whsq.id,
       whsq.webhook_id,
       whsq.seconds_delay,
       whsq.transaction_id,
       whsq.event,
       whsq.payload,
       whsq.signature,
       whsq.created_at,
       whsq.last_sent_at,
       sw.store_id,
       sw.url,
       (select count(distinct id)
        from webhook_send_histories
        where webhook_send_histories.status = 'failed'
          and webhook_send_histories.send_queue_job_id = whsq.id) as retries_count
FROM webhook_send_queue whsq
         join store_webhooks sw on whsq.webhook_id = sw.id and sw.enabled = true
         left join webhook_send_histories whsh on whsh.send_queue_job_id = whsq.id and whsh.status = 'success'
WHERE whsh.id is null
ORDER BY whsq.created_at
LIMIT 500
`

type GetQueuedWebhooksRow struct {
	ID            uuid.UUID        `db:"id" json:"id"`
	WebhookID     uuid.UUID        `db:"webhook_id" json:"webhook_id"`
	SecondsDelay  int16            `db:"seconds_delay" json:"seconds_delay"`
	TransactionID uuid.UUID        `db:"transaction_id" json:"transaction_id"`
	Event         string           `db:"event" json:"event"`
	Payload       []byte           `db:"payload" json:"payload"`
	Signature     string           `db:"signature" json:"signature"`
	CreatedAt     pgtype.Timestamp `db:"created_at" json:"created_at"`
	LastSentAt    pgtype.Timestamp `db:"last_sent_at" json:"last_sent_at"`
	StoreID       uuid.UUID        `db:"store_id" json:"store_id"`
	Url           string           `db:"url" json:"url"`
	RetriesCount  int64            `db:"retries_count" json:"retries_count"`
}

func (q *Queries) GetQueuedWebhooks(ctx context.Context) ([]*GetQueuedWebhooksRow, error) {
	rows, err := q.db.Query(ctx, getQueuedWebhooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetQueuedWebhooksRow{}
	for rows.Next() {
		var i GetQueuedWebhooksRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.SecondsDelay,
			&i.TransactionID,
			&i.Event,
			&i.Payload,
			&i.Signature,
			&i.CreatedAt,
			&i.LastSentAt,
			&i.StoreID,
			&i.Url,
			&i.RetriesCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDelay = `-- name: UpdateDelay :exec
UPDATE webhook_send_queue
set seconds_delay=$2, last_sent_at = now()
where id = $1
`

type UpdateDelayParams struct {
	ID    uuid.UUID `db:"id" json:"id"`
	Delay int16     `db:"delay" json:"delay"`
}

func (q *Queries) UpdateDelay(ctx context.Context, arg UpdateDelayParams) error {
	_, err := q.db.Exec(ctx, updateDelay, arg.ID, arg.Delay)
	return err
}
