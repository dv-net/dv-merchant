// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: currencies_gen.sql

package repo_currencies

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const create = `-- name: Create :one
INSERT INTO currencies (id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, is_stablecoin, currency_label, token_label, is_new_store_default, order_idx)
	VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
	RETURNING id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label, is_new_store_default, order_idx
`

type CreateParams struct {
	ID                   string             `db:"id" json:"id"`
	Code                 string             `db:"code" json:"code"`
	Name                 string             `db:"name" json:"name"`
	Precision            int16              `db:"precision" json:"precision"`
	IsFiat               bool               `db:"is_fiat" json:"is_fiat"`
	Blockchain           *models.Blockchain `db:"blockchain" json:"blockchain"`
	ContractAddress      pgtype.Text        `db:"contract_address" json:"contract_address"`
	WithdrawalMinBalance *decimal.Decimal   `db:"withdrawal_min_balance" json:"withdrawal_min_balance"`
	HasBalance           bool               `db:"has_balance" json:"has_balance"`
	Status               bool               `db:"status" json:"status"`
	SortOrder            int16              `db:"sort_order" json:"sort_order"`
	MinConfirmation      pgtype.Int2        `db:"min_confirmation" json:"min_confirmation"`
	CreatedAt            pgtype.Timestamp   `db:"created_at" json:"created_at"`
	IsStablecoin         bool               `db:"is_stablecoin" json:"is_stablecoin"`
	CurrencyLabel        pgtype.Text        `db:"currency_label" json:"currency_label"`
	TokenLabel           pgtype.Text        `db:"token_label" json:"token_label"`
	IsNewStoreDefault    bool               `db:"is_new_store_default" json:"is_new_store_default"`
	OrderIdx             int64              `db:"order_idx" json:"order_idx"`
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (*models.Currency, error) {
	row := q.db.QueryRow(ctx, create,
		arg.ID,
		arg.Code,
		arg.Name,
		arg.Precision,
		arg.IsFiat,
		arg.Blockchain,
		arg.ContractAddress,
		arg.WithdrawalMinBalance,
		arg.HasBalance,
		arg.Status,
		arg.SortOrder,
		arg.MinConfirmation,
		arg.CreatedAt,
		arg.IsStablecoin,
		arg.CurrencyLabel,
		arg.TokenLabel,
		arg.IsNewStoreDefault,
		arg.OrderIdx,
	)
	var i models.Currency
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Precision,
		&i.IsFiat,
		&i.Blockchain,
		&i.ContractAddress,
		&i.WithdrawalMinBalance,
		&i.HasBalance,
		&i.Status,
		&i.SortOrder,
		&i.MinConfirmation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsStablecoin,
		&i.CurrencyLabel,
		&i.TokenLabel,
		&i.IsNewStoreDefault,
		&i.OrderIdx,
	)
	return &i, err
}

const getAll = `-- name: GetAll :many
SELECT id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label, is_new_store_default, order_idx FROM currencies
`

func (q *Queries) GetAll(ctx context.Context) ([]*models.Currency, error) {
	rows, err := q.db.Query(ctx, getAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Currency{}
	for rows.Next() {
		var i models.Currency
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Precision,
			&i.IsFiat,
			&i.Blockchain,
			&i.ContractAddress,
			&i.WithdrawalMinBalance,
			&i.HasBalance,
			&i.Status,
			&i.SortOrder,
			&i.MinConfirmation,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsStablecoin,
			&i.CurrencyLabel,
			&i.TokenLabel,
			&i.IsNewStoreDefault,
			&i.OrderIdx,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByID = `-- name: GetByID :one
SELECT id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label, is_new_store_default, order_idx FROM currencies WHERE id=$1 LIMIT 1
`

func (q *Queries) GetByID(ctx context.Context, id string) (*models.Currency, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i models.Currency
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Precision,
		&i.IsFiat,
		&i.Blockchain,
		&i.ContractAddress,
		&i.WithdrawalMinBalance,
		&i.HasBalance,
		&i.Status,
		&i.SortOrder,
		&i.MinConfirmation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsStablecoin,
		&i.CurrencyLabel,
		&i.TokenLabel,
		&i.IsNewStoreDefault,
		&i.OrderIdx,
	)
	return &i, err
}
