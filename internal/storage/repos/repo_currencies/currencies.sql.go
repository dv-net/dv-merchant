// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: currencies.sql

package repo_currencies

import (
	"context"
	"github.com/dv-net/dv-merchant/internal/models"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCurrenciesByBlockchain = `-- name: GetCurrenciesByBlockchain :many
SELECT id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label
FROM currencies
WHERE blockchain = $1
`

func (q *Queries) GetCurrenciesByBlockchain(ctx context.Context, blockchain *models.Blockchain) ([]*models.Currency, error) {
	rows, err := q.db.Query(ctx, getCurrenciesByBlockchain, blockchain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Currency{}
	for rows.Next() {
		var i models.Currency
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Precision,
			&i.IsFiat,
			&i.Blockchain,
			&i.ContractAddress,
			&i.WithdrawalMinBalance,
			&i.HasBalance,
			&i.Status,
			&i.SortOrder,
			&i.MinConfirmation,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsStablecoin,
			&i.CurrencyLabel,
			&i.TokenLabel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrenciesEnabled = `-- name: GetCurrenciesEnabled :many
SELECT id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label
FROM currencies
WHERE status = true
ORDER BY blockchain, code
`

func (q *Queries) GetCurrenciesEnabled(ctx context.Context) ([]*models.Currency, error) {
	rows, err := q.db.Query(ctx, getCurrenciesEnabled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Currency{}
	for rows.Next() {
		var i models.Currency
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Precision,
			&i.IsFiat,
			&i.Blockchain,
			&i.ContractAddress,
			&i.WithdrawalMinBalance,
			&i.HasBalance,
			&i.Status,
			&i.SortOrder,
			&i.MinConfirmation,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsStablecoin,
			&i.CurrencyLabel,
			&i.TokenLabel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrenciesHasBalance = `-- name: GetCurrenciesHasBalance :many
SELECT id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label
FROM currencies
where status = true
  and has_balance = true
`

func (q *Queries) GetCurrenciesHasBalance(ctx context.Context) ([]*models.Currency, error) {
	rows, err := q.db.Query(ctx, getCurrenciesHasBalance)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.Currency{}
	for rows.Next() {
		var i models.Currency
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Name,
			&i.Precision,
			&i.IsFiat,
			&i.Blockchain,
			&i.ContractAddress,
			&i.WithdrawalMinBalance,
			&i.HasBalance,
			&i.Status,
			&i.SortOrder,
			&i.MinConfirmation,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsStablecoin,
			&i.CurrencyLabel,
			&i.TokenLabel,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrencyByBlockchainAndContract = `-- name: GetCurrencyByBlockchainAndContract :one
SELECT id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label
FROM currencies
WHERE blockchain = $2
  AND (contract_address = $1 OR (contract_address IS NULL AND code = UPPER($1)))
  AND status = true
LIMIT 1
`

type GetCurrencyByBlockchainAndContractParams struct {
	ContractAddress pgtype.Text        `db:"contract_address" json:"contract_address"`
	Blockchain      *models.Blockchain `db:"blockchain" json:"blockchain"`
}

func (q *Queries) GetCurrencyByBlockchainAndContract(ctx context.Context, arg GetCurrencyByBlockchainAndContractParams) (*models.Currency, error) {
	row := q.db.QueryRow(ctx, getCurrencyByBlockchainAndContract, arg.ContractAddress, arg.Blockchain)
	var i models.Currency
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Precision,
		&i.IsFiat,
		&i.Blockchain,
		&i.ContractAddress,
		&i.WithdrawalMinBalance,
		&i.HasBalance,
		&i.Status,
		&i.SortOrder,
		&i.MinConfirmation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsStablecoin,
		&i.CurrencyLabel,
		&i.TokenLabel,
	)
	return &i, err
}

const getCurrencyWithBalanceByBlockchain = `-- name: GetCurrencyWithBalanceByBlockchain :one
SELECT id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label
FROM currencies
WHERE blockchain = $1
  AND has_balance = true
LIMIT 1
`

func (q *Queries) GetCurrencyWithBalanceByBlockchain(ctx context.Context, blockchain *models.Blockchain) (*models.Currency, error) {
	row := q.db.QueryRow(ctx, getCurrencyWithBalanceByBlockchain, blockchain)
	var i models.Currency
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Precision,
		&i.IsFiat,
		&i.Blockchain,
		&i.ContractAddress,
		&i.WithdrawalMinBalance,
		&i.HasBalance,
		&i.Status,
		&i.SortOrder,
		&i.MinConfirmation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsStablecoin,
		&i.CurrencyLabel,
		&i.TokenLabel,
	)
	return &i, err
}

const getEnabledCurrencyByCode = `-- name: GetEnabledCurrencyByCode :one
SELECT id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label
FROM currencies
WHERE code = $1
  AND status = true
  AND blockchain = $2
LIMIT 1
`

type GetEnabledCurrencyByCodeParams struct {
	Code       string             `db:"code" json:"code"`
	Blockchain *models.Blockchain `db:"blockchain" json:"blockchain"`
}

func (q *Queries) GetEnabledCurrencyByCode(ctx context.Context, arg GetEnabledCurrencyByCodeParams) (*models.Currency, error) {
	row := q.db.QueryRow(ctx, getEnabledCurrencyByCode, arg.Code, arg.Blockchain)
	var i models.Currency
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Precision,
		&i.IsFiat,
		&i.Blockchain,
		&i.ContractAddress,
		&i.WithdrawalMinBalance,
		&i.HasBalance,
		&i.Status,
		&i.SortOrder,
		&i.MinConfirmation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsStablecoin,
		&i.CurrencyLabel,
		&i.TokenLabel,
	)
	return &i, err
}

const getEnabledCurrencyById = `-- name: GetEnabledCurrencyById :one
SELECT id, code, name, precision, is_fiat, blockchain, contract_address, withdrawal_min_balance, has_balance, status, sort_order, min_confirmation, created_at, updated_at, is_stablecoin, currency_label, token_label
FROM currencies
where id = $1 and status = true
limit 1
`

func (q *Queries) GetEnabledCurrencyById(ctx context.Context, id string) (*models.Currency, error) {
	row := q.db.QueryRow(ctx, getEnabledCurrencyById, id)
	var i models.Currency
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Name,
		&i.Precision,
		&i.IsFiat,
		&i.Blockchain,
		&i.ContractAddress,
		&i.WithdrawalMinBalance,
		&i.HasBalance,
		&i.Status,
		&i.SortOrder,
		&i.MinConfirmation,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsStablecoin,
		&i.CurrencyLabel,
		&i.TokenLabel,
	)
	return &i, err
}
