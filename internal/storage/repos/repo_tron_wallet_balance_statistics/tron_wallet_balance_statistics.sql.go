// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tron_wallet_balance_statistics.sql

package repo_tron_wallet_balance_statistics

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const approximateByResolution = `-- name: ApproximateByResolution :many
SELECT
    processing_owner_id,
    AVG(staked_bandwidth)::numeric AS staked_bandwidth,
    AVG(staked_energy)::numeric AS staked_energy,
    AVG(delegated_energy)::numeric AS delegated_energy,
    AVG(delegated_bandwidth)::numeric AS delegated_bandwidth,
    AVG(available_bandwidth)::numeric AS available_bandwidth,
    AVG(available_energy)::numeric AS available_energy,
    DATE_TRUNC($1::varchar, created_at AT TIME ZONE $2::varchar)::timestamp AS day
FROM tron_wallet_balance_statistics
WHERE created_at >= ($3::timestamp AT TIME ZONE $2::varchar)
  AND created_at <= ($4::timestamp AT TIME ZONE $2::varchar)
  AND ($5::uuid IS NULL OR processing_owner_id = $5::uuid)
GROUP BY processing_owner_id, DATE_TRUNC($1::varchar, created_at AT TIME ZONE $2::varchar)
ORDER BY day, processing_owner_id
`

type ApproximateByResolutionParams struct {
	Resolution      string           `db:"resolution" json:"resolution"`
	Timezone        string           `db:"timezone" json:"timezone"`
	DateFrom        pgtype.Timestamp `db:"date_from" json:"date_from"`
	DateTo          pgtype.Timestamp `db:"date_to" json:"date_to"`
	ProcessingOwner uuid.UUID        `db:"processing_owner" json:"processing_owner"`
}

type ApproximateByResolutionRow struct {
	ProcessingOwnerID  uuid.UUID        `db:"processing_owner_id" json:"processing_owner_id"`
	StakedBandwidth    decimal.Decimal  `db:"staked_bandwidth" json:"staked_bandwidth"`
	StakedEnergy       decimal.Decimal  `db:"staked_energy" json:"staked_energy"`
	DelegatedEnergy    decimal.Decimal  `db:"delegated_energy" json:"delegated_energy"`
	DelegatedBandwidth decimal.Decimal  `db:"delegated_bandwidth" json:"delegated_bandwidth"`
	AvailableBandwidth decimal.Decimal  `db:"available_bandwidth" json:"available_bandwidth"`
	AvailableEnergy    decimal.Decimal  `db:"available_energy" json:"available_energy"`
	Day                pgtype.Timestamp `db:"day" json:"day"`
}

func (q *Queries) ApproximateByResolution(ctx context.Context, arg ApproximateByResolutionParams) ([]*ApproximateByResolutionRow, error) {
	rows, err := q.db.Query(ctx, approximateByResolution,
		arg.Resolution,
		arg.Timezone,
		arg.DateFrom,
		arg.DateTo,
		arg.ProcessingOwner,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ApproximateByResolutionRow{}
	for rows.Next() {
		var i ApproximateByResolutionRow
		if err := rows.Scan(
			&i.ProcessingOwnerID,
			&i.StakedBandwidth,
			&i.StakedEnergy,
			&i.DelegatedEnergy,
			&i.DelegatedBandwidth,
			&i.AvailableBandwidth,
			&i.AvailableEnergy,
			&i.Day,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
