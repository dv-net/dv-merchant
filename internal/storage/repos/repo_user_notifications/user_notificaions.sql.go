// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_notificaions.sql

package repo_user_notifications

import (
	"context"
	"github.com/dv-net/dv-merchant/internal/models"

	"github.com/google/uuid"
)

const getByUserAndID = `-- name: GetByUserAndID :one
SELECT un.id, un.user_id, un.notification_id, un.email_enabled, un.tg_enabled, un.created_at, un.updated_at, n.category
from user_notifications un
         INNER JOIN notifications n ON un.notification_id = n.id
WHERE un.id = $1
  and un.user_id = $2
LIMIT 1
`

type GetByUserAndIDParams struct {
	ID     uuid.UUID `db:"id" json:"id"`
	UserID uuid.UUID `db:"user_id" json:"user_id"`
}

type GetByUserAndIDRow struct {
	UserNotification models.UserNotification      `db:"user_notification" json:"user_notification"`
	Category         *models.NotificationCategory `db:"category" json:"category"`
}

func (q *Queries) GetByUserAndID(ctx context.Context, arg GetByUserAndIDParams) (*GetByUserAndIDRow, error) {
	row := q.db.QueryRow(ctx, getByUserAndID, arg.ID, arg.UserID)
	var i GetByUserAndIDRow
	err := row.Scan(
		&i.UserNotification.ID,
		&i.UserNotification.UserID,
		&i.UserNotification.NotificationID,
		&i.UserNotification.EmailEnabled,
		&i.UserNotification.TgEnabled,
		&i.UserNotification.CreatedAt,
		&i.UserNotification.UpdatedAt,
		&i.Category,
	)
	return &i, err
}

const getUserListWithCategory = `-- name: GetUserListWithCategory :many
SELECT n.id,
       COALESCE(n.category, '')::varchar as category,
       n.type,
       coalesce(un.tg_enabled, false),
       coalesce(un.email_enabled, CASE when n.category = 'system' THEN true ELSE false END)
FROM notifications n
         LEFT JOIN user_notifications un ON un.notification_id = n.id AND un.user_id = $1 AND n.category IS NOT NULL
WHERE n.category IS NOT NULL
`

type GetUserListWithCategoryRow struct {
	ID           uuid.UUID               `db:"id" json:"id"`
	Category     string                  `db:"category" json:"category"`
	Type         models.NotificationType `db:"type" json:"type"`
	TgEnabled    bool                    `db:"tg_enabled" json:"tg_enabled"`
	EmailEnabled bool                    `db:"email_enabled" json:"email_enabled"`
}

func (q *Queries) GetUserListWithCategory(ctx context.Context, userID uuid.UUID) ([]*GetUserListWithCategoryRow, error) {
	rows, err := q.db.Query(ctx, getUserListWithCategory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUserListWithCategoryRow{}
	for rows.Next() {
		var i GetUserListWithCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.Category,
			&i.Type,
			&i.TgEnabled,
			&i.EmailEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserNotificationChannels = `-- name: GetUserNotificationChannels :one
SELECT CASE WHEN n.category IS NULL THEN false ELSE coalesce(un.tg_enabled, false) END::bool AS tg_enabled,
       CASE WHEN n.category IS NULL THEN true ELSE coalesce(un.email_enabled, false) END::bool AS email_enabled
FROM notifications n
         LEFT JOIN user_notifications un on un.notification_id = n.id AND un.user_id = $1
WHERE n.type = $2
LIMIT 1
`

type GetUserNotificationChannelsParams struct {
	UserID uuid.UUID               `db:"user_id" json:"user_id"`
	Type   models.NotificationType `db:"type" json:"type"`
}

type GetUserNotificationChannelsRow struct {
	TgEnabled    bool `db:"tg_enabled" json:"tg_enabled"`
	EmailEnabled bool `db:"email_enabled" json:"email_enabled"`
}

func (q *Queries) GetUserNotificationChannels(ctx context.Context, arg GetUserNotificationChannelsParams) (*GetUserNotificationChannelsRow, error) {
	row := q.db.QueryRow(ctx, getUserNotificationChannels, arg.UserID, arg.Type)
	var i GetUserNotificationChannelsRow
	err := row.Scan(&i.TgEnabled, &i.EmailEnabled)
	return &i, err
}
