// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_exchange_pairs_gen.sql

package repo_user_exchange_pairs

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
)

const create = `-- name: Create :one
INSERT INTO user_exchange_pairs (exchange_id, user_id, currency_from, currency_to, symbol, type)
	VALUES ($1, $2, $3, $4, $5, $6)
	RETURNING id, exchange_id, user_id, currency_from, currency_to, symbol, type
`

type CreateParams struct {
	ExchangeID   uuid.UUID        `db:"exchange_id" json:"exchange_id"`
	UserID       uuid.UUID        `db:"user_id" json:"user_id"`
	CurrencyFrom string           `db:"currency_from" json:"currency_from"`
	CurrencyTo   string           `db:"currency_to" json:"currency_to"`
	Symbol       string           `db:"symbol" json:"symbol"`
	Type         models.OrderSide `db:"type" json:"type"`
}

func (q *Queries) Create(ctx context.Context, arg CreateParams) (*models.UserExchangePair, error) {
	row := q.db.QueryRow(ctx, create,
		arg.ExchangeID,
		arg.UserID,
		arg.CurrencyFrom,
		arg.CurrencyTo,
		arg.Symbol,
		arg.Type,
	)
	var i models.UserExchangePair
	err := row.Scan(
		&i.ID,
		&i.ExchangeID,
		&i.UserID,
		&i.CurrencyFrom,
		&i.CurrencyTo,
		&i.Symbol,
		&i.Type,
	)
	return &i, err
}

const find = `-- name: Find :many
SELECT id, exchange_id, user_id, currency_from, currency_to, symbol, type FROM user_exchange_pairs WHERE exchange_id=$1 AND user_id=$2
`

type FindParams struct {
	ExchangeID uuid.UUID `db:"exchange_id" json:"exchange_id"`
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) Find(ctx context.Context, arg FindParams) ([]*models.UserExchangePair, error) {
	rows, err := q.db.Query(ctx, find, arg.ExchangeID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.UserExchangePair{}
	for rows.Next() {
		var i models.UserExchangePair
		if err := rows.Scan(
			&i.ID,
			&i.ExchangeID,
			&i.UserID,
			&i.CurrencyFrom,
			&i.CurrencyTo,
			&i.Symbol,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
