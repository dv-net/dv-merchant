// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package repo_users

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const changeEmail = `-- name: ChangeEmail :exec
UPDATE users
SET email             = $1,
    email_verified_at = null
WHERE email = $2
`

type ChangeEmailParams struct {
	NewEmail string `db:"new_email" json:"new_email" validate:"required,email"`
	OldEmail string `db:"old_email" json:"old_email" validate:"required,email"`
}

func (q *Queries) ChangeEmail(ctx context.Context, arg ChangeEmailParams) error {
	_, err := q.db.Exec(ctx, changeEmail, arg.NewEmail, arg.OldEmail)
	return err
}

const changePassword = `-- name: ChangePassword :one
UPDATE users
SET password=$1,
    updated_at=now()
WHERE id = $2
RETURNING id, email, email_verified_at, password, remember_token, processing_owner_id, location, language, rate_source, created_at, updated_at, deleted_at, banned, exchange_slug, rate_scale, dvnet_token
`

type ChangePasswordParams struct {
	Password string    `db:"password" json:"password" validate:"required,min=8,max=32"`
	ID       uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) ChangePassword(ctx context.Context, arg ChangePasswordParams) (*models.User, error) {
	row := q.db.QueryRow(ctx, changePassword, arg.Password, arg.ID)
	var i models.User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerifiedAt,
		&i.Password,
		&i.RememberToken,
		&i.ProcessingOwnerID,
		&i.Location,
		&i.Language,
		&i.RateSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Banned,
		&i.ExchangeSlug,
		&i.RateScale,
		&i.DvnetToken,
	)
	return &i, err
}

const getActiveProcessingOwnersWithTronDelegate = `-- name: GetActiveProcessingOwnersWithTronDelegate :many
SELECT DISTINCT processing_owner_id
FROM users u
         INNER JOIN settings s
                    ON s.model_id = u.id and s.model_type = 'User' AND s.name = $1 AND
                       s.value = $2
WHERE (u.banned IS NULL OR u.banned = false)
  AND u.deleted_at IS NULL
  AND u.processing_owner_id IS NOT NULL
`

type GetActiveProcessingOwnersWithTronDelegateParams struct {
	TronSettingName  string `db:"tron_setting_name" json:"tron_setting_name"`
	TronSettingValue string `db:"tron_setting_value" json:"tron_setting_value"`
}

func (q *Queries) GetActiveProcessingOwnersWithTronDelegate(ctx context.Context, arg GetActiveProcessingOwnersWithTronDelegateParams) ([]uuid.NullUUID, error) {
	rows, err := q.db.Query(ctx, getActiveProcessingOwnersWithTronDelegate, arg.TronSettingName, arg.TronSettingValue)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []uuid.NullUUID{}
	for rows.Next() {
		var processing_owner_id uuid.NullUUID
		if err := rows.Scan(&processing_owner_id); err != nil {
			return nil, err
		}
		items = append(items, processing_owner_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWithExchangeEnabled = `-- name: GetAllWithExchangeEnabled :many
SELECT id, email, email_verified_at, password, remember_token, processing_owner_id, location, language, rate_source, created_at, updated_at, deleted_at, banned, exchange_slug, rate_scale, dvnet_token
FROM users
WHERE exchange_slug IS NOT NULL
`

func (q *Queries) GetAllWithExchangeEnabled(ctx context.Context) ([]*models.User, error) {
	rows, err := q.db.Query(ctx, getAllWithExchangeEnabled)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.User{}
	for rows.Next() {
		var i models.User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EmailVerifiedAt,
			&i.Password,
			&i.RememberToken,
			&i.ProcessingOwnerID,
			&i.Location,
			&i.Language,
			&i.RateSource,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Banned,
			&i.ExchangeSlug,
			&i.RateScale,
			&i.DvnetToken,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByEmail = `-- name: GetByEmail :one
SELECT id, email, email_verified_at, password, remember_token, processing_owner_id, location, language, rate_source, created_at, updated_at, deleted_at, banned, exchange_slug, rate_scale, dvnet_token
FROM users
WHERE email = $1
LIMIT 1
`

func (q *Queries) GetByEmail(ctx context.Context, email string) (*models.User, error) {
	row := q.db.QueryRow(ctx, getByEmail, email)
	var i models.User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerifiedAt,
		&i.Password,
		&i.RememberToken,
		&i.ProcessingOwnerID,
		&i.Location,
		&i.Language,
		&i.RateSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Banned,
		&i.ExchangeSlug,
		&i.RateScale,
		&i.DvnetToken,
	)
	return &i, err
}

const getByID = `-- name: GetByID :one
SELECT id, email, email_verified_at, password, remember_token, processing_owner_id, location, language, rate_source, created_at, updated_at, deleted_at, banned, exchange_slug, rate_scale, dvnet_token
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetByID(ctx context.Context, id uuid.UUID) (*models.User, error) {
	row := q.db.QueryRow(ctx, getByID, id)
	var i models.User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerifiedAt,
		&i.Password,
		&i.RememberToken,
		&i.ProcessingOwnerID,
		&i.Location,
		&i.Language,
		&i.RateSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Banned,
		&i.ExchangeSlug,
		&i.RateScale,
		&i.DvnetToken,
	)
	return &i, err
}

const getUnverifed = `-- name: GetUnverifed :many
SELECT id, email, email_verified_at, password, remember_token, processing_owner_id, location, language, rate_source, created_at, updated_at, deleted_at, banned, exchange_slug, rate_scale, dvnet_token
FROM users
WHERE email_verified_at IS NULL
  AND created_at < NOW() - INTERVAL '30 day'
`

func (q *Queries) GetUnverifed(ctx context.Context) ([]*models.User, error) {
	rows, err := q.db.Query(ctx, getUnverifed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.User{}
	for rows.Next() {
		var i models.User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.EmailVerifiedAt,
			&i.Password,
			&i.RememberToken,
			&i.ProcessingOwnerID,
			&i.Location,
			&i.Language,
			&i.RateSource,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Banned,
			&i.ExchangeSlug,
			&i.RateScale,
			&i.DvnetToken,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setEmail = `-- name: SetEmail :exec
UPDATE users
SET email             = $2,
    email_verified_at = null
WHERE id = $1
`

type SetEmailParams struct {
	ID    uuid.UUID `db:"id" json:"id"`
	Email string    `db:"email" json:"email" validate:"required,email"`
}

func (q *Queries) SetEmail(ctx context.Context, arg SetEmailParams) error {
	_, err := q.db.Exec(ctx, setEmail, arg.ID, arg.Email)
	return err
}

const updateBanned = `-- name: UpdateBanned :one
UPDATE users
SET banned=$1,
    updated_at=now()
WHERE id = $2
RETURNING id, email, email_verified_at, password, remember_token, processing_owner_id, location, language, rate_source, created_at, updated_at, deleted_at, banned, exchange_slug, rate_scale, dvnet_token
`

type UpdateBannedParams struct {
	Banned pgtype.Bool `db:"banned" json:"banned"`
	ID     uuid.UUID   `db:"id" json:"id"`
}

func (q *Queries) UpdateBanned(ctx context.Context, arg UpdateBannedParams) (*models.User, error) {
	row := q.db.QueryRow(ctx, updateBanned, arg.Banned, arg.ID)
	var i models.User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerifiedAt,
		&i.Password,
		&i.RememberToken,
		&i.ProcessingOwnerID,
		&i.Location,
		&i.Language,
		&i.RateSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Banned,
		&i.ExchangeSlug,
		&i.RateScale,
		&i.DvnetToken,
	)
	return &i, err
}

const updateDvToken = `-- name: UpdateDvToken :exec
UPDATE users
set dvnet_token = $2
WHERE id = $1
`

type UpdateDvTokenParams struct {
	ID         uuid.UUID   `db:"id" json:"id"`
	DvnetToken pgtype.Text `db:"dvnet_token" json:"dvnet_token"`
}

func (q *Queries) UpdateDvToken(ctx context.Context, arg UpdateDvTokenParams) error {
	_, err := q.db.Exec(ctx, updateDvToken, arg.ID, arg.DvnetToken)
	return err
}

const updateEmailVerifiedAt = `-- name: UpdateEmailVerifiedAt :one
UPDATE users
SET email_verified_at=now(),
    updated_at=now()
WHERE id = $1
RETURNING id, email, email_verified_at, password, remember_token, processing_owner_id, location, language, rate_source, created_at, updated_at, deleted_at, banned, exchange_slug, rate_scale, dvnet_token
`

func (q *Queries) UpdateEmailVerifiedAt(ctx context.Context, id uuid.UUID) (*models.User, error) {
	row := q.db.QueryRow(ctx, updateEmailVerifiedAt, id)
	var i models.User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerifiedAt,
		&i.Password,
		&i.RememberToken,
		&i.ProcessingOwnerID,
		&i.Location,
		&i.Language,
		&i.RateSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Banned,
		&i.ExchangeSlug,
		&i.RateScale,
		&i.DvnetToken,
	)
	return &i, err
}

const updateExchange = `-- name: UpdateExchange :one
UPDATE users
SET exchange_slug=$1,
    updated_at=now()
WHERE id = $2
RETURNING id, email, email_verified_at, password, remember_token, processing_owner_id, location, language, rate_source, created_at, updated_at, deleted_at, banned, exchange_slug, rate_scale, dvnet_token
`

type UpdateExchangeParams struct {
	ExchangeSlug *models.ExchangeSlug `db:"exchange_slug" json:"exchange_slug"`
	ID           uuid.UUID            `db:"id" json:"id"`
}

func (q *Queries) UpdateExchange(ctx context.Context, arg UpdateExchangeParams) (*models.User, error) {
	row := q.db.QueryRow(ctx, updateExchange, arg.ExchangeSlug, arg.ID)
	var i models.User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerifiedAt,
		&i.Password,
		&i.RememberToken,
		&i.ProcessingOwnerID,
		&i.Location,
		&i.Language,
		&i.RateSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Banned,
		&i.ExchangeSlug,
		&i.RateScale,
		&i.DvnetToken,
	)
	return &i, err
}

const updateProcessingOwnerId = `-- name: UpdateProcessingOwnerId :one
UPDATE users
SET processing_owner_id=$1,
    updated_at=now()
WHERE id = $2
RETURNING id, email, email_verified_at, password, remember_token, processing_owner_id, location, language, rate_source, created_at, updated_at, deleted_at, banned, exchange_slug, rate_scale, dvnet_token
`

type UpdateProcessingOwnerIdParams struct {
	ProcessingOwnerID uuid.NullUUID `db:"processing_owner_id" json:"processing_owner_id"`
	ID                uuid.UUID     `db:"id" json:"id"`
}

func (q *Queries) UpdateProcessingOwnerId(ctx context.Context, arg UpdateProcessingOwnerIdParams) (*models.User, error) {
	row := q.db.QueryRow(ctx, updateProcessingOwnerId, arg.ProcessingOwnerID, arg.ID)
	var i models.User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.EmailVerifiedAt,
		&i.Password,
		&i.RememberToken,
		&i.ProcessingOwnerID,
		&i.Location,
		&i.Language,
		&i.RateSource,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Banned,
		&i.ExchangeSlug,
		&i.RateScale,
		&i.DvnetToken,
	)
	return &i, err
}

const updateRate = `-- name: UpdateRate :exec
UPDATE users
SET rate_scale=$1,
    rate_source = $2,
    updated_at=now()
WHERE id = $3
`

type UpdateRateParams struct {
	RateScale  decimal.Decimal   `db:"rate_scale" json:"rate_scale"`
	RateSource models.RateSource `db:"rate_source" json:"rate_source"`
	ID         uuid.UUID         `db:"id" json:"id"`
}

func (q *Queries) UpdateRate(ctx context.Context, arg UpdateRateParams) error {
	_, err := q.db.Exec(ctx, updateRate, arg.RateScale, arg.RateSource, arg.ID)
	return err
}
