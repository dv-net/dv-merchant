// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: exchange_withdrawal_settings.sql

package repo_exchange_withdrawal_settings

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const changeAddress = `-- name: ChangeAddress :exec
UPDATE exchange_withdrawal_settings
SET address = $1
WHERE id = $2 AND user_id = $3
`

type ChangeAddressParams struct {
	Address string    `db:"address" json:"address"`
	ID      uuid.UUID `db:"id" json:"id"`
	UserID  uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) ChangeAddress(ctx context.Context, arg ChangeAddressParams) error {
	_, err := q.db.Exec(ctx, changeAddress, arg.Address, arg.ID, arg.UserID)
	return err
}

const changeMinAmount = `-- name: ChangeMinAmount :exec
UPDATE exchange_withdrawal_settings
    SET min_amount = $1
    WHERE id = $2 AND user_id = $3
`

type ChangeMinAmountParams struct {
	MinAmount decimal.Decimal `db:"min_amount" json:"min_amount"`
	ID        uuid.UUID       `db:"id" json:"id"`
	UserID    uuid.UUID       `db:"user_id" json:"user_id"`
}

func (q *Queries) ChangeMinAmount(ctx context.Context, arg ChangeMinAmountParams) error {
	_, err := q.db.Exec(ctx, changeMinAmount, arg.MinAmount, arg.ID, arg.UserID)
	return err
}

const delete = `-- name: Delete :exec
DELETE FROM exchange_withdrawal_settings WHERE id = $1 AND user_id = $2 AND exchange_id = $3
`

type DeleteParams struct {
	ID         uuid.UUID `db:"id" json:"id"`
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	ExchangeID uuid.UUID `db:"exchange_id" json:"exchange_id"`
}

func (q *Queries) Delete(ctx context.Context, arg DeleteParams) error {
	_, err := q.db.Exec(ctx, delete, arg.ID, arg.UserID, arg.ExchangeID)
	return err
}

const deleteByUserAndExchangeID = `-- name: DeleteByUserAndExchangeID :exec
DELETE FROM exchange_withdrawal_settings WHERE user_id = $1 AND exchange_id = $2
`

type DeleteByUserAndExchangeIDParams struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	ExchangeID uuid.UUID `db:"exchange_id" json:"exchange_id"`
}

func (q *Queries) DeleteByUserAndExchangeID(ctx context.Context, arg DeleteByUserAndExchangeIDParams) error {
	_, err := q.db.Exec(ctx, deleteByUserAndExchangeID, arg.UserID, arg.ExchangeID)
	return err
}

const getActive = `-- name: GetActive :many
SELECT ews.id, ews.user_id, ews.exchange_id, ews.currency, ews.chain, ews.address, ews.min_amount, ews.created_at, ews.updated_at, ews.is_enabled FROM exchange_withdrawal_settings ews
INNER JOIN user_exchanges ue ON ue.user_id = ews.user_id AND ue.exchange_id = ews.exchange_id
WHERE ews.is_enabled = true AND ue.withdrawal_state = 'enabled'
`

func (q *Queries) GetActive(ctx context.Context) ([]*models.ExchangeWithdrawalSetting, error) {
	rows, err := q.db.Query(ctx, getActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.ExchangeWithdrawalSetting{}
	for rows.Next() {
		var i models.ExchangeWithdrawalSetting
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExchangeID,
			&i.Currency,
			&i.Chain,
			&i.Address,
			&i.MinAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAddressesWithEnabledCurr = `-- name: GetAllAddressesWithEnabledCurr :many
SELECT distinct ews.address, c.blockchain
FROM exchange_withdrawal_settings ews
         INNER JOIN currencies c on c.id = ews.currency AND c.status = true
WHERE user_id = $1
`

type GetAllAddressesWithEnabledCurrRow struct {
	Address    string             `db:"address" json:"address"`
	Blockchain *models.Blockchain `db:"blockchain" json:"blockchain"`
}

func (q *Queries) GetAllAddressesWithEnabledCurr(ctx context.Context, userID uuid.UUID) ([]*GetAllAddressesWithEnabledCurrRow, error) {
	rows, err := q.db.Query(ctx, getAllAddressesWithEnabledCurr, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllAddressesWithEnabledCurrRow{}
	for rows.Next() {
		var i GetAllAddressesWithEnabledCurrRow
		if err := rows.Scan(&i.Address, &i.Blockchain); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllByUser = `-- name: GetAllByUser :many
SELECT id, user_id, exchange_id, currency, chain, address, min_amount, created_at, updated_at, is_enabled FROM exchange_withdrawal_settings
    WHERE user_id = $1 AND exchange_id = $2
`

type GetAllByUserParams struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	ExchangeID uuid.UUID `db:"exchange_id" json:"exchange_id"`
}

func (q *Queries) GetAllByUser(ctx context.Context, arg GetAllByUserParams) ([]*models.ExchangeWithdrawalSetting, error) {
	rows, err := q.db.Query(ctx, getAllByUser, arg.UserID, arg.ExchangeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*models.ExchangeWithdrawalSetting{}
	for rows.Next() {
		var i models.ExchangeWithdrawalSetting
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ExchangeID,
			&i.Currency,
			&i.Chain,
			&i.Address,
			&i.MinAmount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsEnabled,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByID = `-- name: GetByID :one
SELECT id, user_id, exchange_id, currency, chain, address, min_amount, created_at, updated_at, is_enabled FROM exchange_withdrawal_settings
WHERE user_id = $1 AND exchange_id = $2 AND id = $3
`

type GetByIDParams struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	ExchangeID uuid.UUID `db:"exchange_id" json:"exchange_id"`
	ID         uuid.UUID `db:"id" json:"id"`
}

func (q *Queries) GetByID(ctx context.Context, arg GetByIDParams) (*models.ExchangeWithdrawalSetting, error) {
	row := q.db.QueryRow(ctx, getByID, arg.UserID, arg.ExchangeID, arg.ID)
	var i models.ExchangeWithdrawalSetting
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExchangeID,
		&i.Currency,
		&i.Chain,
		&i.Address,
		&i.MinAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsEnabled,
	)
	return &i, err
}

const getExisting = `-- name: GetExisting :one
SELECT id, user_id, exchange_id, currency, chain, address, min_amount, created_at, updated_at, is_enabled FROM exchange_withdrawal_settings
    WHERE user_id = $1 AND exchange_id = $2 AND currency = $3 AND chain = $4
`

type GetExistingParams struct {
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	ExchangeID uuid.UUID `db:"exchange_id" json:"exchange_id"`
	Currency   string    `db:"currency" json:"currency"`
	Chain      string    `db:"chain" json:"chain"`
}

func (q *Queries) GetExisting(ctx context.Context, arg GetExistingParams) (*models.ExchangeWithdrawalSetting, error) {
	row := q.db.QueryRow(ctx, getExisting,
		arg.UserID,
		arg.ExchangeID,
		arg.Currency,
		arg.Chain,
	)
	var i models.ExchangeWithdrawalSetting
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExchangeID,
		&i.Currency,
		&i.Chain,
		&i.Address,
		&i.MinAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsEnabled,
	)
	return &i, err
}

const update = `-- name: Update :one
UPDATE exchange_withdrawal_settings
SET min_amount = COALESCE($1, min_amount),
    is_enabled = COALESCE($2, is_enabled)
WHERE id = $3
  AND user_id = $4
RETURNING id, user_id, exchange_id, currency, chain, address, min_amount, created_at, updated_at, is_enabled
`

type UpdateParams struct {
	MinAmount decimal.NullDecimal `db:"min_amount" json:"min_amount"`
	Enabled   pgtype.Bool         `db:"enabled" json:"enabled"`
	ID        uuid.UUID           `db:"id" json:"id"`
	UserID    uuid.UUID           `db:"user_id" json:"user_id"`
}

func (q *Queries) Update(ctx context.Context, arg UpdateParams) (*models.ExchangeWithdrawalSetting, error) {
	row := q.db.QueryRow(ctx, update,
		arg.MinAmount,
		arg.Enabled,
		arg.ID,
		arg.UserID,
	)
	var i models.ExchangeWithdrawalSetting
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExchangeID,
		&i.Currency,
		&i.Chain,
		&i.Address,
		&i.MinAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsEnabled,
	)
	return &i, err
}

const updateIsEnabledByID = `-- name: UpdateIsEnabledByID :one
UPDATE exchange_withdrawal_settings
SET is_enabled = $1
WHERE id = $2 AND user_id = $3
RETURNING id, user_id, exchange_id, currency, chain, address, min_amount, created_at, updated_at, is_enabled
`

type UpdateIsEnabledByIDParams struct {
	NewState bool      `db:"new_state" json:"new_state"`
	ID       uuid.UUID `db:"id" json:"id"`
	UserID   uuid.UUID `db:"user_id" json:"user_id"`
}

func (q *Queries) UpdateIsEnabledByID(ctx context.Context, arg UpdateIsEnabledByIDParams) (*models.ExchangeWithdrawalSetting, error) {
	row := q.db.QueryRow(ctx, updateIsEnabledByID, arg.NewState, arg.ID, arg.UserID)
	var i models.ExchangeWithdrawalSetting
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ExchangeID,
		&i.Currency,
		&i.Chain,
		&i.Address,
		&i.MinAmount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsEnabled,
	)
	return &i, err
}

const updateIsEnabledByUserAndExchangeID = `-- name: UpdateIsEnabledByUserAndExchangeID :exec
UPDATE exchange_withdrawal_settings
SET is_enabled = $3
WHERE user_id = $2 AND exchange_id = $1
`

type UpdateIsEnabledByUserAndExchangeIDParams struct {
	ExchangeID uuid.UUID `db:"exchange_id" json:"exchange_id"`
	UserID     uuid.UUID `db:"user_id" json:"user_id"`
	IsEnabled  bool      `db:"is_enabled" json:"is_enabled"`
}

func (q *Queries) UpdateIsEnabledByUserAndExchangeID(ctx context.Context, arg UpdateIsEnabledByUserAndExchangeIDParams) error {
	_, err := q.db.Exec(ctx, updateIsEnabledByUserAndExchangeID, arg.ExchangeID, arg.UserID, arg.IsEnabled)
	return err
}
