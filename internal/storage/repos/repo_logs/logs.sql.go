// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: logs.sql

package repo_logs

import (
	"context"

	"github.com/dv-net/dv-merchant/internal/models"
	"github.com/google/uuid"
)

const deleteLogBySlug = `-- name: DeleteLogBySlug :exec
DELETE FROM logs WHERE log_type_slug = $1 and process_id != $2
`

type DeleteLogBySlugParams struct {
	LogTypeSlug string    `db:"log_type_slug" json:"log_type_slug"`
	ProcessID   uuid.UUID `db:"process_id" json:"process_id"`
}

func (q *Queries) DeleteLogBySlug(ctx context.Context, arg DeleteLogBySlugParams) error {
	_, err := q.db.Exec(ctx, deleteLogBySlug, arg.LogTypeSlug, arg.ProcessID)
	return err
}

const getByProcessID = `-- name: GetByProcessID :one
SELECT id, log_type_slug, process_id, level, status, message, created_at FROM logs WHERE process_id=$1 ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) GetByProcessID(ctx context.Context, processID uuid.UUID) (*models.Log, error) {
	row := q.db.QueryRow(ctx, getByProcessID, processID)
	var i models.Log
	err := row.Scan(
		&i.ID,
		&i.LogTypeSlug,
		&i.ProcessID,
		&i.Level,
		&i.Status,
		&i.Message,
		&i.CreatedAt,
	)
	return &i, err
}

const getLogsBySlug = `-- name: GetLogsBySlug :many
WITH grouped_logs AS (
    SELECT
        process_id,
        JSONB_AGG(
                JSONB_BUILD_OBJECT(
                        'status', status,
                        'message', message,
                        'created_at', created_at
                ) ORDER BY created_at
        ) AS messages,
        MIN(created_at) AS created_at,
        MAX(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) > 0 AS failure
    FROM logs
    WHERE log_type_slug = $1
    GROUP BY process_id
    LIMIT 100
)
SELECT
    process_id,
    failure,
    created_at,
    messages AS messages
FROM grouped_logs
`

type GetLogsBySlugRow struct {
	ProcessID uuid.UUID   `db:"process_id" json:"process_id"`
	Failure   bool        `db:"failure" json:"failure"`
	CreatedAt interface{} `db:"created_at" json:"created_at"`
	Messages  []byte      `db:"messages" json:"messages"`
}

func (q *Queries) GetLogsBySlug(ctx context.Context, logTypeSlug string) ([]*GetLogsBySlugRow, error) {
	rows, err := q.db.Query(ctx, getLogsBySlug, logTypeSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetLogsBySlugRow{}
	for rows.Next() {
		var i GetLogsBySlugRow
		if err := rows.Scan(
			&i.ProcessID,
			&i.Failure,
			&i.CreatedAt,
			&i.Messages,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
