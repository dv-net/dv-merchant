// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	context "context"

	decimal "github.com/shopspring/decimal"

	mock "github.com/stretchr/testify/mock"

	models "github.com/dv-net/dv-merchant/internal/models"
)

// IExchangeClient is an autogenerated mock type for the IExchangeClient type
type IExchangeClient struct {
	mock.Mock
}

type IExchangeClient_Expecter struct {
	mock *mock.Mock
}

func (_m *IExchangeClient) EXPECT() *IExchangeClient_Expecter {
	return &IExchangeClient_Expecter{mock: &_m.Mock}
}

// CreateSpotOrder provides a mock function with given fields: ctx, from, to, side, ticker, amount, rule
func (_m *IExchangeClient) CreateSpotOrder(ctx context.Context, from string, to string, side string, ticker string, amount *decimal.Decimal, rule *models.OrderRulesDTO) (*models.ExchangeOrderDTO, error) {
	ret := _m.Called(ctx, from, to, side, ticker, amount, rule)

	if len(ret) == 0 {
		panic("no return value specified for CreateSpotOrder")
	}

	var r0 *models.ExchangeOrderDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, *decimal.Decimal, *models.OrderRulesDTO) (*models.ExchangeOrderDTO, error)); ok {
		return rf(ctx, from, to, side, ticker, amount, rule)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string, *decimal.Decimal, *models.OrderRulesDTO) *models.ExchangeOrderDTO); ok {
		r0 = rf(ctx, from, to, side, ticker, amount, rule)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ExchangeOrderDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string, *decimal.Decimal, *models.OrderRulesDTO) error); ok {
		r1 = rf(ctx, from, to, side, ticker, amount, rule)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_CreateSpotOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSpotOrder'
type IExchangeClient_CreateSpotOrder_Call struct {
	*mock.Call
}

// CreateSpotOrder is a helper method to define mock.On call
//   - ctx context.Context
//   - from string
//   - to string
//   - side string
//   - ticker string
//   - amount *decimal.Decimal
//   - rule *models.OrderRulesDTO
func (_e *IExchangeClient_Expecter) CreateSpotOrder(ctx interface{}, from interface{}, to interface{}, side interface{}, ticker interface{}, amount interface{}, rule interface{}) *IExchangeClient_CreateSpotOrder_Call {
	return &IExchangeClient_CreateSpotOrder_Call{Call: _e.mock.On("CreateSpotOrder", ctx, from, to, side, ticker, amount, rule)}
}

func (_c *IExchangeClient_CreateSpotOrder_Call) Run(run func(ctx context.Context, from string, to string, side string, ticker string, amount *decimal.Decimal, rule *models.OrderRulesDTO)) *IExchangeClient_CreateSpotOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(string), args[5].(*decimal.Decimal), args[6].(*models.OrderRulesDTO))
	})
	return _c
}

func (_c *IExchangeClient_CreateSpotOrder_Call) Return(_a0 *models.ExchangeOrderDTO, _a1 error) *IExchangeClient_CreateSpotOrder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_CreateSpotOrder_Call) RunAndReturn(run func(context.Context, string, string, string, string, *decimal.Decimal, *models.OrderRulesDTO) (*models.ExchangeOrderDTO, error)) *IExchangeClient_CreateSpotOrder_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWithdrawalOrder provides a mock function with given fields: ctx, args
func (_m *IExchangeClient) CreateWithdrawalOrder(ctx context.Context, args *models.CreateWithdrawalOrderParams) (*models.ExchangeWithdrawalDTO, error) {
	ret := _m.Called(ctx, args)

	if len(ret) == 0 {
		panic("no return value specified for CreateWithdrawalOrder")
	}

	var r0 *models.ExchangeWithdrawalDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.CreateWithdrawalOrderParams) (*models.ExchangeWithdrawalDTO, error)); ok {
		return rf(ctx, args)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.CreateWithdrawalOrderParams) *models.ExchangeWithdrawalDTO); ok {
		r0 = rf(ctx, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ExchangeWithdrawalDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.CreateWithdrawalOrderParams) error); ok {
		r1 = rf(ctx, args)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_CreateWithdrawalOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWithdrawalOrder'
type IExchangeClient_CreateWithdrawalOrder_Call struct {
	*mock.Call
}

// CreateWithdrawalOrder is a helper method to define mock.On call
//   - ctx context.Context
//   - args *models.CreateWithdrawalOrderParams
func (_e *IExchangeClient_Expecter) CreateWithdrawalOrder(ctx interface{}, args interface{}) *IExchangeClient_CreateWithdrawalOrder_Call {
	return &IExchangeClient_CreateWithdrawalOrder_Call{Call: _e.mock.On("CreateWithdrawalOrder", ctx, args)}
}

func (_c *IExchangeClient_CreateWithdrawalOrder_Call) Run(run func(ctx context.Context, args *models.CreateWithdrawalOrderParams)) *IExchangeClient_CreateWithdrawalOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.CreateWithdrawalOrderParams))
	})
	return _c
}

func (_c *IExchangeClient_CreateWithdrawalOrder_Call) Return(_a0 *models.ExchangeWithdrawalDTO, _a1 error) *IExchangeClient_CreateWithdrawalOrder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_CreateWithdrawalOrder_Call) RunAndReturn(run func(context.Context, *models.CreateWithdrawalOrderParams) (*models.ExchangeWithdrawalDTO, error)) *IExchangeClient_CreateWithdrawalOrder_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccountBalance provides a mock function with given fields: ctx
func (_m *IExchangeClient) GetAccountBalance(ctx context.Context) ([]*models.AccountBalanceDTO, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountBalance")
	}

	var r0 []*models.AccountBalanceDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*models.AccountBalanceDTO, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*models.AccountBalanceDTO); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.AccountBalanceDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_GetAccountBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccountBalance'
type IExchangeClient_GetAccountBalance_Call struct {
	*mock.Call
}

// GetAccountBalance is a helper method to define mock.On call
//   - ctx context.Context
func (_e *IExchangeClient_Expecter) GetAccountBalance(ctx interface{}) *IExchangeClient_GetAccountBalance_Call {
	return &IExchangeClient_GetAccountBalance_Call{Call: _e.mock.On("GetAccountBalance", ctx)}
}

func (_c *IExchangeClient_GetAccountBalance_Call) Run(run func(ctx context.Context)) *IExchangeClient_GetAccountBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *IExchangeClient_GetAccountBalance_Call) Return(_a0 []*models.AccountBalanceDTO, _a1 error) *IExchangeClient_GetAccountBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_GetAccountBalance_Call) RunAndReturn(run func(context.Context) ([]*models.AccountBalanceDTO, error)) *IExchangeClient_GetAccountBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetConnectionHash provides a mock function with no fields
func (_m *IExchangeClient) GetConnectionHash() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetConnectionHash")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// IExchangeClient_GetConnectionHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConnectionHash'
type IExchangeClient_GetConnectionHash_Call struct {
	*mock.Call
}

// GetConnectionHash is a helper method to define mock.On call
func (_e *IExchangeClient_Expecter) GetConnectionHash() *IExchangeClient_GetConnectionHash_Call {
	return &IExchangeClient_GetConnectionHash_Call{Call: _e.mock.On("GetConnectionHash")}
}

func (_c *IExchangeClient_GetConnectionHash_Call) Run(run func()) *IExchangeClient_GetConnectionHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IExchangeClient_GetConnectionHash_Call) Return(_a0 string) *IExchangeClient_GetConnectionHash_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IExchangeClient_GetConnectionHash_Call) RunAndReturn(run func() string) *IExchangeClient_GetConnectionHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetCurrencyBalance provides a mock function with given fields: ctx, currency
func (_m *IExchangeClient) GetCurrencyBalance(ctx context.Context, currency string) (*decimal.Decimal, error) {
	ret := _m.Called(ctx, currency)

	if len(ret) == 0 {
		panic("no return value specified for GetCurrencyBalance")
	}

	var r0 *decimal.Decimal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*decimal.Decimal, error)); ok {
		return rf(ctx, currency)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *decimal.Decimal); ok {
		r0 = rf(ctx, currency)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*decimal.Decimal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, currency)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_GetCurrencyBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCurrencyBalance'
type IExchangeClient_GetCurrencyBalance_Call struct {
	*mock.Call
}

// GetCurrencyBalance is a helper method to define mock.On call
//   - ctx context.Context
//   - currency string
func (_e *IExchangeClient_Expecter) GetCurrencyBalance(ctx interface{}, currency interface{}) *IExchangeClient_GetCurrencyBalance_Call {
	return &IExchangeClient_GetCurrencyBalance_Call{Call: _e.mock.On("GetCurrencyBalance", ctx, currency)}
}

func (_c *IExchangeClient_GetCurrencyBalance_Call) Run(run func(ctx context.Context, currency string)) *IExchangeClient_GetCurrencyBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *IExchangeClient_GetCurrencyBalance_Call) Return(_a0 *decimal.Decimal, _a1 error) *IExchangeClient_GetCurrencyBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_GetCurrencyBalance_Call) RunAndReturn(run func(context.Context, string) (*decimal.Decimal, error)) *IExchangeClient_GetCurrencyBalance_Call {
	_c.Call.Return(run)
	return _c
}

// GetDepositAddresses provides a mock function with given fields: ctx, currency, network
func (_m *IExchangeClient) GetDepositAddresses(ctx context.Context, currency string, network string) ([]*models.DepositAddressDTO, error) {
	ret := _m.Called(ctx, currency, network)

	if len(ret) == 0 {
		panic("no return value specified for GetDepositAddresses")
	}

	var r0 []*models.DepositAddressDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]*models.DepositAddressDTO, error)); ok {
		return rf(ctx, currency, network)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*models.DepositAddressDTO); ok {
		r0 = rf(ctx, currency, network)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.DepositAddressDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, currency, network)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_GetDepositAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDepositAddresses'
type IExchangeClient_GetDepositAddresses_Call struct {
	*mock.Call
}

// GetDepositAddresses is a helper method to define mock.On call
//   - ctx context.Context
//   - currency string
//   - network string
func (_e *IExchangeClient_Expecter) GetDepositAddresses(ctx interface{}, currency interface{}, network interface{}) *IExchangeClient_GetDepositAddresses_Call {
	return &IExchangeClient_GetDepositAddresses_Call{Call: _e.mock.On("GetDepositAddresses", ctx, currency, network)}
}

func (_c *IExchangeClient_GetDepositAddresses_Call) Run(run func(ctx context.Context, currency string, network string)) *IExchangeClient_GetDepositAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *IExchangeClient_GetDepositAddresses_Call) Return(_a0 []*models.DepositAddressDTO, _a1 error) *IExchangeClient_GetDepositAddresses_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_GetDepositAddresses_Call) RunAndReturn(run func(context.Context, string, string) ([]*models.DepositAddressDTO, error)) *IExchangeClient_GetDepositAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// GetExchangeSymbols provides a mock function with given fields: ctx
func (_m *IExchangeClient) GetExchangeSymbols(ctx context.Context) ([]*models.ExchangeSymbolDTO, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetExchangeSymbols")
	}

	var r0 []*models.ExchangeSymbolDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*models.ExchangeSymbolDTO, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*models.ExchangeSymbolDTO); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.ExchangeSymbolDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_GetExchangeSymbols_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExchangeSymbols'
type IExchangeClient_GetExchangeSymbols_Call struct {
	*mock.Call
}

// GetExchangeSymbols is a helper method to define mock.On call
//   - ctx context.Context
func (_e *IExchangeClient_Expecter) GetExchangeSymbols(ctx interface{}) *IExchangeClient_GetExchangeSymbols_Call {
	return &IExchangeClient_GetExchangeSymbols_Call{Call: _e.mock.On("GetExchangeSymbols", ctx)}
}

func (_c *IExchangeClient_GetExchangeSymbols_Call) Run(run func(ctx context.Context)) *IExchangeClient_GetExchangeSymbols_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *IExchangeClient_GetExchangeSymbols_Call) Return(_a0 []*models.ExchangeSymbolDTO, _a1 error) *IExchangeClient_GetExchangeSymbols_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_GetExchangeSymbols_Call) RunAndReturn(run func(context.Context) ([]*models.ExchangeSymbolDTO, error)) *IExchangeClient_GetExchangeSymbols_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrderDetails provides a mock function with given fields: ctx, args
func (_m *IExchangeClient) GetOrderDetails(ctx context.Context, args *models.GetOrderByIDParams) (*models.OrderDetailsDTO, error) {
	ret := _m.Called(ctx, args)

	if len(ret) == 0 {
		panic("no return value specified for GetOrderDetails")
	}

	var r0 *models.OrderDetailsDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.GetOrderByIDParams) (*models.OrderDetailsDTO, error)); ok {
		return rf(ctx, args)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.GetOrderByIDParams) *models.OrderDetailsDTO); ok {
		r0 = rf(ctx, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.OrderDetailsDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.GetOrderByIDParams) error); ok {
		r1 = rf(ctx, args)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_GetOrderDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrderDetails'
type IExchangeClient_GetOrderDetails_Call struct {
	*mock.Call
}

// GetOrderDetails is a helper method to define mock.On call
//   - ctx context.Context
//   - args *models.GetOrderByIDParams
func (_e *IExchangeClient_Expecter) GetOrderDetails(ctx interface{}, args interface{}) *IExchangeClient_GetOrderDetails_Call {
	return &IExchangeClient_GetOrderDetails_Call{Call: _e.mock.On("GetOrderDetails", ctx, args)}
}

func (_c *IExchangeClient_GetOrderDetails_Call) Run(run func(ctx context.Context, args *models.GetOrderByIDParams)) *IExchangeClient_GetOrderDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.GetOrderByIDParams))
	})
	return _c
}

func (_c *IExchangeClient_GetOrderDetails_Call) Return(_a0 *models.OrderDetailsDTO, _a1 error) *IExchangeClient_GetOrderDetails_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_GetOrderDetails_Call) RunAndReturn(run func(context.Context, *models.GetOrderByIDParams) (*models.OrderDetailsDTO, error)) *IExchangeClient_GetOrderDetails_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrderRule provides a mock function with given fields: ctx, ticker
func (_m *IExchangeClient) GetOrderRule(ctx context.Context, ticker string) (*models.OrderRulesDTO, error) {
	ret := _m.Called(ctx, ticker)

	if len(ret) == 0 {
		panic("no return value specified for GetOrderRule")
	}

	var r0 *models.OrderRulesDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*models.OrderRulesDTO, error)); ok {
		return rf(ctx, ticker)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *models.OrderRulesDTO); ok {
		r0 = rf(ctx, ticker)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.OrderRulesDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, ticker)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_GetOrderRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrderRule'
type IExchangeClient_GetOrderRule_Call struct {
	*mock.Call
}

// GetOrderRule is a helper method to define mock.On call
//   - ctx context.Context
//   - ticker string
func (_e *IExchangeClient_Expecter) GetOrderRule(ctx interface{}, ticker interface{}) *IExchangeClient_GetOrderRule_Call {
	return &IExchangeClient_GetOrderRule_Call{Call: _e.mock.On("GetOrderRule", ctx, ticker)}
}

func (_c *IExchangeClient_GetOrderRule_Call) Run(run func(ctx context.Context, ticker string)) *IExchangeClient_GetOrderRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *IExchangeClient_GetOrderRule_Call) Return(_a0 *models.OrderRulesDTO, _a1 error) *IExchangeClient_GetOrderRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_GetOrderRule_Call) RunAndReturn(run func(context.Context, string) (*models.OrderRulesDTO, error)) *IExchangeClient_GetOrderRule_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrderRules provides a mock function with given fields: ctx, tickers
func (_m *IExchangeClient) GetOrderRules(ctx context.Context, tickers ...string) ([]*models.OrderRulesDTO, error) {
	_va := make([]interface{}, len(tickers))
	for _i := range tickers {
		_va[_i] = tickers[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetOrderRules")
	}

	var r0 []*models.OrderRulesDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...string) ([]*models.OrderRulesDTO, error)); ok {
		return rf(ctx, tickers...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...string) []*models.OrderRulesDTO); ok {
		r0 = rf(ctx, tickers...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.OrderRulesDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...string) error); ok {
		r1 = rf(ctx, tickers...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_GetOrderRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrderRules'
type IExchangeClient_GetOrderRules_Call struct {
	*mock.Call
}

// GetOrderRules is a helper method to define mock.On call
//   - ctx context.Context
//   - tickers ...string
func (_e *IExchangeClient_Expecter) GetOrderRules(ctx interface{}, tickers ...interface{}) *IExchangeClient_GetOrderRules_Call {
	return &IExchangeClient_GetOrderRules_Call{Call: _e.mock.On("GetOrderRules",
		append([]interface{}{ctx}, tickers...)...)}
}

func (_c *IExchangeClient_GetOrderRules_Call) Run(run func(ctx context.Context, tickers ...string)) *IExchangeClient_GetOrderRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *IExchangeClient_GetOrderRules_Call) Return(_a0 []*models.OrderRulesDTO, _a1 error) *IExchangeClient_GetOrderRules_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_GetOrderRules_Call) RunAndReturn(run func(context.Context, ...string) ([]*models.OrderRulesDTO, error)) *IExchangeClient_GetOrderRules_Call {
	_c.Call.Return(run)
	return _c
}

// GetWithdrawalByID provides a mock function with given fields: ctx, args
func (_m *IExchangeClient) GetWithdrawalByID(ctx context.Context, args *models.GetWithdrawalByIDParams) (*models.WithdrawalStatusDTO, error) {
	ret := _m.Called(ctx, args)

	if len(ret) == 0 {
		panic("no return value specified for GetWithdrawalByID")
	}

	var r0 *models.WithdrawalStatusDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.GetWithdrawalByIDParams) (*models.WithdrawalStatusDTO, error)); ok {
		return rf(ctx, args)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.GetWithdrawalByIDParams) *models.WithdrawalStatusDTO); ok {
		r0 = rf(ctx, args)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.WithdrawalStatusDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.GetWithdrawalByIDParams) error); ok {
		r1 = rf(ctx, args)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_GetWithdrawalByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWithdrawalByID'
type IExchangeClient_GetWithdrawalByID_Call struct {
	*mock.Call
}

// GetWithdrawalByID is a helper method to define mock.On call
//   - ctx context.Context
//   - args *models.GetWithdrawalByIDParams
func (_e *IExchangeClient_Expecter) GetWithdrawalByID(ctx interface{}, args interface{}) *IExchangeClient_GetWithdrawalByID_Call {
	return &IExchangeClient_GetWithdrawalByID_Call{Call: _e.mock.On("GetWithdrawalByID", ctx, args)}
}

func (_c *IExchangeClient_GetWithdrawalByID_Call) Run(run func(ctx context.Context, args *models.GetWithdrawalByIDParams)) *IExchangeClient_GetWithdrawalByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.GetWithdrawalByIDParams))
	})
	return _c
}

func (_c *IExchangeClient_GetWithdrawalByID_Call) Return(_a0 *models.WithdrawalStatusDTO, _a1 error) *IExchangeClient_GetWithdrawalByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_GetWithdrawalByID_Call) RunAndReturn(run func(context.Context, *models.GetWithdrawalByIDParams) (*models.WithdrawalStatusDTO, error)) *IExchangeClient_GetWithdrawalByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetWithdrawalRules provides a mock function with given fields: ctx, ccys
func (_m *IExchangeClient) GetWithdrawalRules(ctx context.Context, ccys ...string) ([]*models.WithdrawalRulesDTO, error) {
	_va := make([]interface{}, len(ccys))
	for _i := range ccys {
		_va[_i] = ccys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetWithdrawalRules")
	}

	var r0 []*models.WithdrawalRulesDTO
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...string) ([]*models.WithdrawalRulesDTO, error)); ok {
		return rf(ctx, ccys...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...string) []*models.WithdrawalRulesDTO); ok {
		r0 = rf(ctx, ccys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*models.WithdrawalRulesDTO)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...string) error); ok {
		r1 = rf(ctx, ccys...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IExchangeClient_GetWithdrawalRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWithdrawalRules'
type IExchangeClient_GetWithdrawalRules_Call struct {
	*mock.Call
}

// GetWithdrawalRules is a helper method to define mock.On call
//   - ctx context.Context
//   - ccys ...string
func (_e *IExchangeClient_Expecter) GetWithdrawalRules(ctx interface{}, ccys ...interface{}) *IExchangeClient_GetWithdrawalRules_Call {
	return &IExchangeClient_GetWithdrawalRules_Call{Call: _e.mock.On("GetWithdrawalRules",
		append([]interface{}{ctx}, ccys...)...)}
}

func (_c *IExchangeClient_GetWithdrawalRules_Call) Run(run func(ctx context.Context, ccys ...string)) *IExchangeClient_GetWithdrawalRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *IExchangeClient_GetWithdrawalRules_Call) Return(_a0 []*models.WithdrawalRulesDTO, _a1 error) *IExchangeClient_GetWithdrawalRules_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IExchangeClient_GetWithdrawalRules_Call) RunAndReturn(run func(context.Context, ...string) ([]*models.WithdrawalRulesDTO, error)) *IExchangeClient_GetWithdrawalRules_Call {
	_c.Call.Return(run)
	return _c
}

// TestConnection provides a mock function with given fields: ctx
func (_m *IExchangeClient) TestConnection(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for TestConnection")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IExchangeClient_TestConnection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TestConnection'
type IExchangeClient_TestConnection_Call struct {
	*mock.Call
}

// TestConnection is a helper method to define mock.On call
//   - ctx context.Context
func (_e *IExchangeClient_Expecter) TestConnection(ctx interface{}) *IExchangeClient_TestConnection_Call {
	return &IExchangeClient_TestConnection_Call{Call: _e.mock.On("TestConnection", ctx)}
}

func (_c *IExchangeClient_TestConnection_Call) Run(run func(ctx context.Context)) *IExchangeClient_TestConnection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *IExchangeClient_TestConnection_Call) Return(_a0 error) *IExchangeClient_TestConnection_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IExchangeClient_TestConnection_Call) RunAndReturn(run func(context.Context) error) *IExchangeClient_TestConnection_Call {
	_c.Call.Return(run)
	return _c
}

// NewIExchangeClient creates a new instance of IExchangeClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIExchangeClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *IExchangeClient {
	mock := &IExchangeClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
