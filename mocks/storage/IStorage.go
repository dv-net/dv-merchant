// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	key_value "github.com/dv-net/dv-merchant/pkg/key_value"

	mock "github.com/stretchr/testify/mock"

	pgxpool "github.com/jackc/pgx/v5/pgxpool"

	repo_aml_check_history "github.com/dv-net/dv-merchant/internal/storage/repos/repo_aml_check_history"

	repo_aml_check_queue "github.com/dv-net/dv-merchant/internal/storage/repos/repo_aml_check_queue"

	repo_aml_checks "github.com/dv-net/dv-merchant/internal/storage/repos/repo_aml_checks"

	repo_aml_service_keys "github.com/dv-net/dv-merchant/internal/storage/repos/repo_aml_service_keys"

	repo_aml_services "github.com/dv-net/dv-merchant/internal/storage/repos/repo_aml_services"

	repo_aml_supported_assets "github.com/dv-net/dv-merchant/internal/storage/repos/repo_aml_supported_assets"

	repo_aml_user_keys "github.com/dv-net/dv-merchant/internal/storage/repos/repo_aml_user_keys"

	repo_analytics "github.com/dv-net/dv-merchant/internal/storage/repos/repo_analytics"

	repo_currencies "github.com/dv-net/dv-merchant/internal/storage/repos/repo_currencies"

	repo_currency_exrate "github.com/dv-net/dv-merchant/internal/storage/repos/repo_currency_exrate"

	repo_exchange_addresses "github.com/dv-net/dv-merchant/internal/storage/repos/repo_exchange_addresses"

	repo_exchange_chains "github.com/dv-net/dv-merchant/internal/storage/repos/repo_exchange_chains"

	repo_exchange_orders "github.com/dv-net/dv-merchant/internal/storage/repos/repo_exchange_orders"

	repo_exchange_user_keys "github.com/dv-net/dv-merchant/internal/storage/repos/repo_exchange_user_keys"

	repo_exchange_withdrawal_history "github.com/dv-net/dv-merchant/internal/storage/repos/repo_exchange_withdrawal_history"

	repo_exchange_withdrawal_settings "github.com/dv-net/dv-merchant/internal/storage/repos/repo_exchange_withdrawal_settings"

	repo_exchanges "github.com/dv-net/dv-merchant/internal/storage/repos/repo_exchanges"

	repo_log_types "github.com/dv-net/dv-merchant/internal/storage/repos/repo_log_types"

	repo_logs "github.com/dv-net/dv-merchant/internal/storage/repos/repo_logs"

	repo_multi_withdrawal_rules "github.com/dv-net/dv-merchant/internal/storage/repos/repo_multi_withdrawal_rules"

	repo_notification_send_history "github.com/dv-net/dv-merchant/internal/storage/repos/repo_notification_send_history"

	repo_notification_send_queue "github.com/dv-net/dv-merchant/internal/storage/repos/repo_notification_send_queue"

	repo_notifications "github.com/dv-net/dv-merchant/internal/storage/repos/repo_notifications"

	repo_personal_access_tokens "github.com/dv-net/dv-merchant/internal/storage/repos/repo_personal_access_tokens"

	repo_receipts "github.com/dv-net/dv-merchant/internal/storage/repos/repo_receipts"

	repo_settings "github.com/dv-net/dv-merchant/internal/storage/repos/repo_settings"

	repo_store_api_keys "github.com/dv-net/dv-merchant/internal/storage/repos/repo_store_api_keys"

	repo_store_currencies "github.com/dv-net/dv-merchant/internal/storage/repos/repo_store_currencies"

	repo_store_secrets "github.com/dv-net/dv-merchant/internal/storage/repos/repo_store_secrets"

	repo_store_webhooks "github.com/dv-net/dv-merchant/internal/storage/repos/repo_store_webhooks"

	repo_store_whitelist "github.com/dv-net/dv-merchant/internal/storage/repos/repo_store_whitelist"

	repo_stores "github.com/dv-net/dv-merchant/internal/storage/repos/repo_stores"

	repo_transactions "github.com/dv-net/dv-merchant/internal/storage/repos/repo_transactions"

	repo_transfer_transactions "github.com/dv-net/dv-merchant/internal/storage/repos/repo_transfer_transactions"

	repo_transfers "github.com/dv-net/dv-merchant/internal/storage/repos/repo_transfers"

	repo_tron_wallet_balance_statistics "github.com/dv-net/dv-merchant/internal/storage/repos/repo_tron_wallet_balance_statistics"

	repo_unconfirmed_transactions "github.com/dv-net/dv-merchant/internal/storage/repos/repo_unconfirmed_transactions"

	repo_update_balance_queue "github.com/dv-net/dv-merchant/internal/storage/repos/repo_update_balance_queue"

	repo_user_exchange_pairs "github.com/dv-net/dv-merchant/internal/storage/repos/repo_user_exchange_pairs"

	repo_user_exchanges "github.com/dv-net/dv-merchant/internal/storage/repos/repo_user_exchanges"

	repo_user_notifications "github.com/dv-net/dv-merchant/internal/storage/repos/repo_user_notifications"

	repo_user_stores "github.com/dv-net/dv-merchant/internal/storage/repos/repo_user_stores"

	repo_users "github.com/dv-net/dv-merchant/internal/storage/repos/repo_users"

	repo_wallet_addresses "github.com/dv-net/dv-merchant/internal/storage/repos/repo_wallet_addresses"

	repo_wallet_addresses_activity_logs "github.com/dv-net/dv-merchant/internal/storage/repos/repo_wallet_addresses_activity_logs"

	repo_wallets "github.com/dv-net/dv-merchant/internal/storage/repos/repo_wallets"

	repo_webhook_send_histories "github.com/dv-net/dv-merchant/internal/storage/repos/repo_webhook_send_histories"

	repo_webhook_send_queue "github.com/dv-net/dv-merchant/internal/storage/repos/repo_webhook_send_queue"

	repo_withdrawal_from_processing_wallets "github.com/dv-net/dv-merchant/internal/storage/repos/repo_withdrawal_from_processing_wallets"

	repo_withdrawal_wallet_addresses "github.com/dv-net/dv-merchant/internal/storage/repos/repo_withdrawal_wallet_addresses"

	repo_withdrawal_wallets "github.com/dv-net/dv-merchant/internal/storage/repos/repo_withdrawal_wallets"

	repos "github.com/dv-net/dv-merchant/internal/storage/repos"
)

// IStorage is an autogenerated mock type for the IStorage type
type IStorage struct {
	mock.Mock
}

type IStorage_Expecter struct {
	mock *mock.Mock
}

func (_m *IStorage) EXPECT() *IStorage_Expecter {
	return &IStorage_Expecter{mock: &_m.Mock}
}

// AmlCheckHistory provides a mock function with given fields: opts
func (_m *IStorage) AmlCheckHistory(opts ...repos.Option) repo_aml_check_history.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AmlCheckHistory")
	}

	var r0 repo_aml_check_history.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_aml_check_history.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_aml_check_history.Querier)
		}
	}

	return r0
}

// IStorage_AmlCheckHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AmlCheckHistory'
type IStorage_AmlCheckHistory_Call struct {
	*mock.Call
}

// AmlCheckHistory is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) AmlCheckHistory(opts ...interface{}) *IStorage_AmlCheckHistory_Call {
	return &IStorage_AmlCheckHistory_Call{Call: _e.mock.On("AmlCheckHistory",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_AmlCheckHistory_Call) Run(run func(opts ...repos.Option)) *IStorage_AmlCheckHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_AmlCheckHistory_Call) Return(_a0 repo_aml_check_history.Querier) *IStorage_AmlCheckHistory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_AmlCheckHistory_Call) RunAndReturn(run func(...repos.Option) repo_aml_check_history.Querier) *IStorage_AmlCheckHistory_Call {
	_c.Call.Return(run)
	return _c
}

// AmlCheckQueue provides a mock function with given fields: opts
func (_m *IStorage) AmlCheckQueue(opts ...repos.Option) repo_aml_check_queue.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AmlCheckQueue")
	}

	var r0 repo_aml_check_queue.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_aml_check_queue.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_aml_check_queue.Querier)
		}
	}

	return r0
}

// IStorage_AmlCheckQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AmlCheckQueue'
type IStorage_AmlCheckQueue_Call struct {
	*mock.Call
}

// AmlCheckQueue is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) AmlCheckQueue(opts ...interface{}) *IStorage_AmlCheckQueue_Call {
	return &IStorage_AmlCheckQueue_Call{Call: _e.mock.On("AmlCheckQueue",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_AmlCheckQueue_Call) Run(run func(opts ...repos.Option)) *IStorage_AmlCheckQueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_AmlCheckQueue_Call) Return(_a0 repo_aml_check_queue.Querier) *IStorage_AmlCheckQueue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_AmlCheckQueue_Call) RunAndReturn(run func(...repos.Option) repo_aml_check_queue.Querier) *IStorage_AmlCheckQueue_Call {
	_c.Call.Return(run)
	return _c
}

// AmlChecks provides a mock function with given fields: opts
func (_m *IStorage) AmlChecks(opts ...repos.Option) repo_aml_checks.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AmlChecks")
	}

	var r0 repo_aml_checks.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_aml_checks.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_aml_checks.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_AmlChecks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AmlChecks'
type IStorage_AmlChecks_Call struct {
	*mock.Call
}

// AmlChecks is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) AmlChecks(opts ...interface{}) *IStorage_AmlChecks_Call {
	return &IStorage_AmlChecks_Call{Call: _e.mock.On("AmlChecks",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_AmlChecks_Call) Run(run func(opts ...repos.Option)) *IStorage_AmlChecks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_AmlChecks_Call) Return(_a0 repo_aml_checks.ICustomQuerier) *IStorage_AmlChecks_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_AmlChecks_Call) RunAndReturn(run func(...repos.Option) repo_aml_checks.ICustomQuerier) *IStorage_AmlChecks_Call {
	_c.Call.Return(run)
	return _c
}

// AmlServiceKeys provides a mock function with given fields: opts
func (_m *IStorage) AmlServiceKeys(opts ...repos.Option) repo_aml_service_keys.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AmlServiceKeys")
	}

	var r0 repo_aml_service_keys.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_aml_service_keys.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_aml_service_keys.Querier)
		}
	}

	return r0
}

// IStorage_AmlServiceKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AmlServiceKeys'
type IStorage_AmlServiceKeys_Call struct {
	*mock.Call
}

// AmlServiceKeys is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) AmlServiceKeys(opts ...interface{}) *IStorage_AmlServiceKeys_Call {
	return &IStorage_AmlServiceKeys_Call{Call: _e.mock.On("AmlServiceKeys",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_AmlServiceKeys_Call) Run(run func(opts ...repos.Option)) *IStorage_AmlServiceKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_AmlServiceKeys_Call) Return(_a0 repo_aml_service_keys.Querier) *IStorage_AmlServiceKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_AmlServiceKeys_Call) RunAndReturn(run func(...repos.Option) repo_aml_service_keys.Querier) *IStorage_AmlServiceKeys_Call {
	_c.Call.Return(run)
	return _c
}

// AmlServices provides a mock function with given fields: opts
func (_m *IStorage) AmlServices(opts ...repos.Option) repo_aml_services.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AmlServices")
	}

	var r0 repo_aml_services.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_aml_services.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_aml_services.Querier)
		}
	}

	return r0
}

// IStorage_AmlServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AmlServices'
type IStorage_AmlServices_Call struct {
	*mock.Call
}

// AmlServices is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) AmlServices(opts ...interface{}) *IStorage_AmlServices_Call {
	return &IStorage_AmlServices_Call{Call: _e.mock.On("AmlServices",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_AmlServices_Call) Run(run func(opts ...repos.Option)) *IStorage_AmlServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_AmlServices_Call) Return(_a0 repo_aml_services.Querier) *IStorage_AmlServices_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_AmlServices_Call) RunAndReturn(run func(...repos.Option) repo_aml_services.Querier) *IStorage_AmlServices_Call {
	_c.Call.Return(run)
	return _c
}

// AmlSupportedAssets provides a mock function with given fields: opts
func (_m *IStorage) AmlSupportedAssets(opts ...repos.Option) repo_aml_supported_assets.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AmlSupportedAssets")
	}

	var r0 repo_aml_supported_assets.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_aml_supported_assets.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_aml_supported_assets.Querier)
		}
	}

	return r0
}

// IStorage_AmlSupportedAssets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AmlSupportedAssets'
type IStorage_AmlSupportedAssets_Call struct {
	*mock.Call
}

// AmlSupportedAssets is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) AmlSupportedAssets(opts ...interface{}) *IStorage_AmlSupportedAssets_Call {
	return &IStorage_AmlSupportedAssets_Call{Call: _e.mock.On("AmlSupportedAssets",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_AmlSupportedAssets_Call) Run(run func(opts ...repos.Option)) *IStorage_AmlSupportedAssets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_AmlSupportedAssets_Call) Return(_a0 repo_aml_supported_assets.Querier) *IStorage_AmlSupportedAssets_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_AmlSupportedAssets_Call) RunAndReturn(run func(...repos.Option) repo_aml_supported_assets.Querier) *IStorage_AmlSupportedAssets_Call {
	_c.Call.Return(run)
	return _c
}

// AmlUserKeys provides a mock function with given fields: opts
func (_m *IStorage) AmlUserKeys(opts ...repos.Option) repo_aml_user_keys.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AmlUserKeys")
	}

	var r0 repo_aml_user_keys.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_aml_user_keys.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_aml_user_keys.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_AmlUserKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AmlUserKeys'
type IStorage_AmlUserKeys_Call struct {
	*mock.Call
}

// AmlUserKeys is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) AmlUserKeys(opts ...interface{}) *IStorage_AmlUserKeys_Call {
	return &IStorage_AmlUserKeys_Call{Call: _e.mock.On("AmlUserKeys",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_AmlUserKeys_Call) Run(run func(opts ...repos.Option)) *IStorage_AmlUserKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_AmlUserKeys_Call) Return(_a0 repo_aml_user_keys.ICustomQuerier) *IStorage_AmlUserKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_AmlUserKeys_Call) RunAndReturn(run func(...repos.Option) repo_aml_user_keys.ICustomQuerier) *IStorage_AmlUserKeys_Call {
	_c.Call.Return(run)
	return _c
}

// Analytics provides a mock function with given fields: opts
func (_m *IStorage) Analytics(opts ...repos.Option) repo_analytics.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Analytics")
	}

	var r0 repo_analytics.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_analytics.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_analytics.Querier)
		}
	}

	return r0
}

// IStorage_Analytics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Analytics'
type IStorage_Analytics_Call struct {
	*mock.Call
}

// Analytics is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Analytics(opts ...interface{}) *IStorage_Analytics_Call {
	return &IStorage_Analytics_Call{Call: _e.mock.On("Analytics",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Analytics_Call) Run(run func(opts ...repos.Option)) *IStorage_Analytics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Analytics_Call) Return(_a0 repo_analytics.Querier) *IStorage_Analytics_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Analytics_Call) RunAndReturn(run func(...repos.Option) repo_analytics.Querier) *IStorage_Analytics_Call {
	_c.Call.Return(run)
	return _c
}

// Close provides a mock function with no fields
func (_m *IStorage) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IStorage_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type IStorage_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *IStorage_Expecter) Close() *IStorage_Close_Call {
	return &IStorage_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *IStorage_Close_Call) Run(run func()) *IStorage_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IStorage_Close_Call) Return(_a0 error) *IStorage_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Close_Call) RunAndReturn(run func() error) *IStorage_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Currencies provides a mock function with given fields: opts
func (_m *IStorage) Currencies(opts ...repos.Option) repo_currencies.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Currencies")
	}

	var r0 repo_currencies.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_currencies.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_currencies.Querier)
		}
	}

	return r0
}

// IStorage_Currencies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Currencies'
type IStorage_Currencies_Call struct {
	*mock.Call
}

// Currencies is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Currencies(opts ...interface{}) *IStorage_Currencies_Call {
	return &IStorage_Currencies_Call{Call: _e.mock.On("Currencies",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Currencies_Call) Run(run func(opts ...repos.Option)) *IStorage_Currencies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Currencies_Call) Return(_a0 repo_currencies.Querier) *IStorage_Currencies_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Currencies_Call) RunAndReturn(run func(...repos.Option) repo_currencies.Querier) *IStorage_Currencies_Call {
	_c.Call.Return(run)
	return _c
}

// CurrencyExchange provides a mock function with no fields
func (_m *IStorage) CurrencyExchange() repo_currency_exrate.ICurrencyRateRepo {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CurrencyExchange")
	}

	var r0 repo_currency_exrate.ICurrencyRateRepo
	if rf, ok := ret.Get(0).(func() repo_currency_exrate.ICurrencyRateRepo); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_currency_exrate.ICurrencyRateRepo)
		}
	}

	return r0
}

// IStorage_CurrencyExchange_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrencyExchange'
type IStorage_CurrencyExchange_Call struct {
	*mock.Call
}

// CurrencyExchange is a helper method to define mock.On call
func (_e *IStorage_Expecter) CurrencyExchange() *IStorage_CurrencyExchange_Call {
	return &IStorage_CurrencyExchange_Call{Call: _e.mock.On("CurrencyExchange")}
}

func (_c *IStorage_CurrencyExchange_Call) Run(run func()) *IStorage_CurrencyExchange_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IStorage_CurrencyExchange_Call) Return(_a0 repo_currency_exrate.ICurrencyRateRepo) *IStorage_CurrencyExchange_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_CurrencyExchange_Call) RunAndReturn(run func() repo_currency_exrate.ICurrencyRateRepo) *IStorage_CurrencyExchange_Call {
	_c.Call.Return(run)
	return _c
}

// ExchangeAddresses provides a mock function with given fields: opts
func (_m *IStorage) ExchangeAddresses(opts ...repos.Option) repo_exchange_addresses.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExchangeAddresses")
	}

	var r0 repo_exchange_addresses.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_exchange_addresses.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_exchange_addresses.Querier)
		}
	}

	return r0
}

// IStorage_ExchangeAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExchangeAddresses'
type IStorage_ExchangeAddresses_Call struct {
	*mock.Call
}

// ExchangeAddresses is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) ExchangeAddresses(opts ...interface{}) *IStorage_ExchangeAddresses_Call {
	return &IStorage_ExchangeAddresses_Call{Call: _e.mock.On("ExchangeAddresses",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_ExchangeAddresses_Call) Run(run func(opts ...repos.Option)) *IStorage_ExchangeAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_ExchangeAddresses_Call) Return(_a0 repo_exchange_addresses.Querier) *IStorage_ExchangeAddresses_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_ExchangeAddresses_Call) RunAndReturn(run func(...repos.Option) repo_exchange_addresses.Querier) *IStorage_ExchangeAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// ExchangeChains provides a mock function with given fields: opts
func (_m *IStorage) ExchangeChains(opts ...repos.Option) repo_exchange_chains.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExchangeChains")
	}

	var r0 repo_exchange_chains.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_exchange_chains.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_exchange_chains.Querier)
		}
	}

	return r0
}

// IStorage_ExchangeChains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExchangeChains'
type IStorage_ExchangeChains_Call struct {
	*mock.Call
}

// ExchangeChains is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) ExchangeChains(opts ...interface{}) *IStorage_ExchangeChains_Call {
	return &IStorage_ExchangeChains_Call{Call: _e.mock.On("ExchangeChains",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_ExchangeChains_Call) Run(run func(opts ...repos.Option)) *IStorage_ExchangeChains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_ExchangeChains_Call) Return(_a0 repo_exchange_chains.Querier) *IStorage_ExchangeChains_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_ExchangeChains_Call) RunAndReturn(run func(...repos.Option) repo_exchange_chains.Querier) *IStorage_ExchangeChains_Call {
	_c.Call.Return(run)
	return _c
}

// ExchangeOrders provides a mock function with given fields: opts
func (_m *IStorage) ExchangeOrders(opts ...repos.Option) repo_exchange_orders.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExchangeOrders")
	}

	var r0 repo_exchange_orders.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_exchange_orders.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_exchange_orders.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_ExchangeOrders_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExchangeOrders'
type IStorage_ExchangeOrders_Call struct {
	*mock.Call
}

// ExchangeOrders is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) ExchangeOrders(opts ...interface{}) *IStorage_ExchangeOrders_Call {
	return &IStorage_ExchangeOrders_Call{Call: _e.mock.On("ExchangeOrders",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_ExchangeOrders_Call) Run(run func(opts ...repos.Option)) *IStorage_ExchangeOrders_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_ExchangeOrders_Call) Return(_a0 repo_exchange_orders.ICustomQuerier) *IStorage_ExchangeOrders_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_ExchangeOrders_Call) RunAndReturn(run func(...repos.Option) repo_exchange_orders.ICustomQuerier) *IStorage_ExchangeOrders_Call {
	_c.Call.Return(run)
	return _c
}

// ExchangeUserKeys provides a mock function with given fields: opts
func (_m *IStorage) ExchangeUserKeys(opts ...repos.Option) repo_exchange_user_keys.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExchangeUserKeys")
	}

	var r0 repo_exchange_user_keys.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_exchange_user_keys.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_exchange_user_keys.Querier)
		}
	}

	return r0
}

// IStorage_ExchangeUserKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExchangeUserKeys'
type IStorage_ExchangeUserKeys_Call struct {
	*mock.Call
}

// ExchangeUserKeys is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) ExchangeUserKeys(opts ...interface{}) *IStorage_ExchangeUserKeys_Call {
	return &IStorage_ExchangeUserKeys_Call{Call: _e.mock.On("ExchangeUserKeys",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_ExchangeUserKeys_Call) Run(run func(opts ...repos.Option)) *IStorage_ExchangeUserKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_ExchangeUserKeys_Call) Return(_a0 repo_exchange_user_keys.Querier) *IStorage_ExchangeUserKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_ExchangeUserKeys_Call) RunAndReturn(run func(...repos.Option) repo_exchange_user_keys.Querier) *IStorage_ExchangeUserKeys_Call {
	_c.Call.Return(run)
	return _c
}

// ExchangeWithdrawalHistory provides a mock function with given fields: opts
func (_m *IStorage) ExchangeWithdrawalHistory(opts ...repos.Option) repo_exchange_withdrawal_history.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExchangeWithdrawalHistory")
	}

	var r0 repo_exchange_withdrawal_history.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_exchange_withdrawal_history.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_exchange_withdrawal_history.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_ExchangeWithdrawalHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExchangeWithdrawalHistory'
type IStorage_ExchangeWithdrawalHistory_Call struct {
	*mock.Call
}

// ExchangeWithdrawalHistory is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) ExchangeWithdrawalHistory(opts ...interface{}) *IStorage_ExchangeWithdrawalHistory_Call {
	return &IStorage_ExchangeWithdrawalHistory_Call{Call: _e.mock.On("ExchangeWithdrawalHistory",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_ExchangeWithdrawalHistory_Call) Run(run func(opts ...repos.Option)) *IStorage_ExchangeWithdrawalHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_ExchangeWithdrawalHistory_Call) Return(_a0 repo_exchange_withdrawal_history.ICustomQuerier) *IStorage_ExchangeWithdrawalHistory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_ExchangeWithdrawalHistory_Call) RunAndReturn(run func(...repos.Option) repo_exchange_withdrawal_history.ICustomQuerier) *IStorage_ExchangeWithdrawalHistory_Call {
	_c.Call.Return(run)
	return _c
}

// ExchangeWithdrawalSettings provides a mock function with given fields: opts
func (_m *IStorage) ExchangeWithdrawalSettings(opts ...repos.Option) repo_exchange_withdrawal_settings.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExchangeWithdrawalSettings")
	}

	var r0 repo_exchange_withdrawal_settings.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_exchange_withdrawal_settings.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_exchange_withdrawal_settings.Querier)
		}
	}

	return r0
}

// IStorage_ExchangeWithdrawalSettings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExchangeWithdrawalSettings'
type IStorage_ExchangeWithdrawalSettings_Call struct {
	*mock.Call
}

// ExchangeWithdrawalSettings is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) ExchangeWithdrawalSettings(opts ...interface{}) *IStorage_ExchangeWithdrawalSettings_Call {
	return &IStorage_ExchangeWithdrawalSettings_Call{Call: _e.mock.On("ExchangeWithdrawalSettings",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_ExchangeWithdrawalSettings_Call) Run(run func(opts ...repos.Option)) *IStorage_ExchangeWithdrawalSettings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_ExchangeWithdrawalSettings_Call) Return(_a0 repo_exchange_withdrawal_settings.Querier) *IStorage_ExchangeWithdrawalSettings_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_ExchangeWithdrawalSettings_Call) RunAndReturn(run func(...repos.Option) repo_exchange_withdrawal_settings.Querier) *IStorage_ExchangeWithdrawalSettings_Call {
	_c.Call.Return(run)
	return _c
}

// Exchanges provides a mock function with given fields: opts
func (_m *IStorage) Exchanges(opts ...repos.Option) repo_exchanges.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exchanges")
	}

	var r0 repo_exchanges.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_exchanges.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_exchanges.Querier)
		}
	}

	return r0
}

// IStorage_Exchanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Exchanges'
type IStorage_Exchanges_Call struct {
	*mock.Call
}

// Exchanges is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Exchanges(opts ...interface{}) *IStorage_Exchanges_Call {
	return &IStorage_Exchanges_Call{Call: _e.mock.On("Exchanges",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Exchanges_Call) Run(run func(opts ...repos.Option)) *IStorage_Exchanges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Exchanges_Call) Return(_a0 repo_exchanges.Querier) *IStorage_Exchanges_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Exchanges_Call) RunAndReturn(run func(...repos.Option) repo_exchanges.Querier) *IStorage_Exchanges_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValue provides a mock function with no fields
func (_m *IStorage) KeyValue() key_value.IKeyValue {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for KeyValue")
	}

	var r0 key_value.IKeyValue
	if rf, ok := ret.Get(0).(func() key_value.IKeyValue); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(key_value.IKeyValue)
		}
	}

	return r0
}

// IStorage_KeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValue'
type IStorage_KeyValue_Call struct {
	*mock.Call
}

// KeyValue is a helper method to define mock.On call
func (_e *IStorage_Expecter) KeyValue() *IStorage_KeyValue_Call {
	return &IStorage_KeyValue_Call{Call: _e.mock.On("KeyValue")}
}

func (_c *IStorage_KeyValue_Call) Run(run func()) *IStorage_KeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IStorage_KeyValue_Call) Return(_a0 key_value.IKeyValue) *IStorage_KeyValue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_KeyValue_Call) RunAndReturn(run func() key_value.IKeyValue) *IStorage_KeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// LogTypes provides a mock function with given fields: opts
func (_m *IStorage) LogTypes(opts ...repos.Option) repo_log_types.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LogTypes")
	}

	var r0 repo_log_types.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_log_types.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_log_types.Querier)
		}
	}

	return r0
}

// IStorage_LogTypes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LogTypes'
type IStorage_LogTypes_Call struct {
	*mock.Call
}

// LogTypes is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) LogTypes(opts ...interface{}) *IStorage_LogTypes_Call {
	return &IStorage_LogTypes_Call{Call: _e.mock.On("LogTypes",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_LogTypes_Call) Run(run func(opts ...repos.Option)) *IStorage_LogTypes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_LogTypes_Call) Return(_a0 repo_log_types.Querier) *IStorage_LogTypes_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_LogTypes_Call) RunAndReturn(run func(...repos.Option) repo_log_types.Querier) *IStorage_LogTypes_Call {
	_c.Call.Return(run)
	return _c
}

// Logs provides a mock function with given fields: opts
func (_m *IStorage) Logs(opts ...repos.Option) repo_logs.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Logs")
	}

	var r0 repo_logs.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_logs.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_logs.Querier)
		}
	}

	return r0
}

// IStorage_Logs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Logs'
type IStorage_Logs_Call struct {
	*mock.Call
}

// Logs is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Logs(opts ...interface{}) *IStorage_Logs_Call {
	return &IStorage_Logs_Call{Call: _e.mock.On("Logs",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Logs_Call) Run(run func(opts ...repos.Option)) *IStorage_Logs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Logs_Call) Return(_a0 repo_logs.Querier) *IStorage_Logs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Logs_Call) RunAndReturn(run func(...repos.Option) repo_logs.Querier) *IStorage_Logs_Call {
	_c.Call.Return(run)
	return _c
}

// MultiWithdrawalRules provides a mock function with given fields: opts
func (_m *IStorage) MultiWithdrawalRules(opts ...repos.Option) repo_multi_withdrawal_rules.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MultiWithdrawalRules")
	}

	var r0 repo_multi_withdrawal_rules.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_multi_withdrawal_rules.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_multi_withdrawal_rules.Querier)
		}
	}

	return r0
}

// IStorage_MultiWithdrawalRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MultiWithdrawalRules'
type IStorage_MultiWithdrawalRules_Call struct {
	*mock.Call
}

// MultiWithdrawalRules is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) MultiWithdrawalRules(opts ...interface{}) *IStorage_MultiWithdrawalRules_Call {
	return &IStorage_MultiWithdrawalRules_Call{Call: _e.mock.On("MultiWithdrawalRules",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_MultiWithdrawalRules_Call) Run(run func(opts ...repos.Option)) *IStorage_MultiWithdrawalRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_MultiWithdrawalRules_Call) Return(_a0 repo_multi_withdrawal_rules.Querier) *IStorage_MultiWithdrawalRules_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_MultiWithdrawalRules_Call) RunAndReturn(run func(...repos.Option) repo_multi_withdrawal_rules.Querier) *IStorage_MultiWithdrawalRules_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationSendHistory provides a mock function with given fields: opts
func (_m *IStorage) NotificationSendHistory(opts ...repos.Option) repo_notification_send_history.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NotificationSendHistory")
	}

	var r0 repo_notification_send_history.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_notification_send_history.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_notification_send_history.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_NotificationSendHistory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationSendHistory'
type IStorage_NotificationSendHistory_Call struct {
	*mock.Call
}

// NotificationSendHistory is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) NotificationSendHistory(opts ...interface{}) *IStorage_NotificationSendHistory_Call {
	return &IStorage_NotificationSendHistory_Call{Call: _e.mock.On("NotificationSendHistory",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_NotificationSendHistory_Call) Run(run func(opts ...repos.Option)) *IStorage_NotificationSendHistory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_NotificationSendHistory_Call) Return(_a0 repo_notification_send_history.ICustomQuerier) *IStorage_NotificationSendHistory_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_NotificationSendHistory_Call) RunAndReturn(run func(...repos.Option) repo_notification_send_history.ICustomQuerier) *IStorage_NotificationSendHistory_Call {
	_c.Call.Return(run)
	return _c
}

// NotificationSendQueue provides a mock function with given fields: opts
func (_m *IStorage) NotificationSendQueue(opts ...repos.Option) repo_notification_send_queue.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NotificationSendQueue")
	}

	var r0 repo_notification_send_queue.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_notification_send_queue.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_notification_send_queue.Querier)
		}
	}

	return r0
}

// IStorage_NotificationSendQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotificationSendQueue'
type IStorage_NotificationSendQueue_Call struct {
	*mock.Call
}

// NotificationSendQueue is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) NotificationSendQueue(opts ...interface{}) *IStorage_NotificationSendQueue_Call {
	return &IStorage_NotificationSendQueue_Call{Call: _e.mock.On("NotificationSendQueue",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_NotificationSendQueue_Call) Run(run func(opts ...repos.Option)) *IStorage_NotificationSendQueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_NotificationSendQueue_Call) Return(_a0 repo_notification_send_queue.Querier) *IStorage_NotificationSendQueue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_NotificationSendQueue_Call) RunAndReturn(run func(...repos.Option) repo_notification_send_queue.Querier) *IStorage_NotificationSendQueue_Call {
	_c.Call.Return(run)
	return _c
}

// Notifications provides a mock function with given fields: opts
func (_m *IStorage) Notifications(opts ...repos.Option) repo_notifications.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Notifications")
	}

	var r0 repo_notifications.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_notifications.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_notifications.Querier)
		}
	}

	return r0
}

// IStorage_Notifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Notifications'
type IStorage_Notifications_Call struct {
	*mock.Call
}

// Notifications is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Notifications(opts ...interface{}) *IStorage_Notifications_Call {
	return &IStorage_Notifications_Call{Call: _e.mock.On("Notifications",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Notifications_Call) Run(run func(opts ...repos.Option)) *IStorage_Notifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Notifications_Call) Return(_a0 repo_notifications.Querier) *IStorage_Notifications_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Notifications_Call) RunAndReturn(run func(...repos.Option) repo_notifications.Querier) *IStorage_Notifications_Call {
	_c.Call.Return(run)
	return _c
}

// PSQLConn provides a mock function with no fields
func (_m *IStorage) PSQLConn() *pgxpool.Pool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PSQLConn")
	}

	var r0 *pgxpool.Pool
	if rf, ok := ret.Get(0).(func() *pgxpool.Pool); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*pgxpool.Pool)
		}
	}

	return r0
}

// IStorage_PSQLConn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PSQLConn'
type IStorage_PSQLConn_Call struct {
	*mock.Call
}

// PSQLConn is a helper method to define mock.On call
func (_e *IStorage_Expecter) PSQLConn() *IStorage_PSQLConn_Call {
	return &IStorage_PSQLConn_Call{Call: _e.mock.On("PSQLConn")}
}

func (_c *IStorage_PSQLConn_Call) Run(run func()) *IStorage_PSQLConn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *IStorage_PSQLConn_Call) Return(_a0 *pgxpool.Pool) *IStorage_PSQLConn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_PSQLConn_Call) RunAndReturn(run func() *pgxpool.Pool) *IStorage_PSQLConn_Call {
	_c.Call.Return(run)
	return _c
}

// PersonalAccessToken provides a mock function with given fields: opts
func (_m *IStorage) PersonalAccessToken(opts ...repos.Option) repo_personal_access_tokens.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PersonalAccessToken")
	}

	var r0 repo_personal_access_tokens.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_personal_access_tokens.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_personal_access_tokens.Querier)
		}
	}

	return r0
}

// IStorage_PersonalAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PersonalAccessToken'
type IStorage_PersonalAccessToken_Call struct {
	*mock.Call
}

// PersonalAccessToken is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) PersonalAccessToken(opts ...interface{}) *IStorage_PersonalAccessToken_Call {
	return &IStorage_PersonalAccessToken_Call{Call: _e.mock.On("PersonalAccessToken",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_PersonalAccessToken_Call) Run(run func(opts ...repos.Option)) *IStorage_PersonalAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_PersonalAccessToken_Call) Return(_a0 repo_personal_access_tokens.Querier) *IStorage_PersonalAccessToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_PersonalAccessToken_Call) RunAndReturn(run func(...repos.Option) repo_personal_access_tokens.Querier) *IStorage_PersonalAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// Receipts provides a mock function with given fields: opts
func (_m *IStorage) Receipts(opts ...repos.Option) repo_receipts.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Receipts")
	}

	var r0 repo_receipts.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_receipts.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_receipts.Querier)
		}
	}

	return r0
}

// IStorage_Receipts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Receipts'
type IStorage_Receipts_Call struct {
	*mock.Call
}

// Receipts is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Receipts(opts ...interface{}) *IStorage_Receipts_Call {
	return &IStorage_Receipts_Call{Call: _e.mock.On("Receipts",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Receipts_Call) Run(run func(opts ...repos.Option)) *IStorage_Receipts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Receipts_Call) Return(_a0 repo_receipts.Querier) *IStorage_Receipts_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Receipts_Call) RunAndReturn(run func(...repos.Option) repo_receipts.Querier) *IStorage_Receipts_Call {
	_c.Call.Return(run)
	return _c
}

// Settings provides a mock function with given fields: opts
func (_m *IStorage) Settings(opts ...repos.Option) repo_settings.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Settings")
	}

	var r0 repo_settings.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_settings.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_settings.Querier)
		}
	}

	return r0
}

// IStorage_Settings_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Settings'
type IStorage_Settings_Call struct {
	*mock.Call
}

// Settings is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Settings(opts ...interface{}) *IStorage_Settings_Call {
	return &IStorage_Settings_Call{Call: _e.mock.On("Settings",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Settings_Call) Run(run func(opts ...repos.Option)) *IStorage_Settings_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Settings_Call) Return(_a0 repo_settings.Querier) *IStorage_Settings_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Settings_Call) RunAndReturn(run func(...repos.Option) repo_settings.Querier) *IStorage_Settings_Call {
	_c.Call.Return(run)
	return _c
}

// StoreAPIKeys provides a mock function with given fields: opts
func (_m *IStorage) StoreAPIKeys(opts ...repos.Option) repo_store_api_keys.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoreAPIKeys")
	}

	var r0 repo_store_api_keys.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_store_api_keys.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_store_api_keys.Querier)
		}
	}

	return r0
}

// IStorage_StoreAPIKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreAPIKeys'
type IStorage_StoreAPIKeys_Call struct {
	*mock.Call
}

// StoreAPIKeys is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) StoreAPIKeys(opts ...interface{}) *IStorage_StoreAPIKeys_Call {
	return &IStorage_StoreAPIKeys_Call{Call: _e.mock.On("StoreAPIKeys",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_StoreAPIKeys_Call) Run(run func(opts ...repos.Option)) *IStorage_StoreAPIKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_StoreAPIKeys_Call) Return(_a0 repo_store_api_keys.Querier) *IStorage_StoreAPIKeys_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_StoreAPIKeys_Call) RunAndReturn(run func(...repos.Option) repo_store_api_keys.Querier) *IStorage_StoreAPIKeys_Call {
	_c.Call.Return(run)
	return _c
}

// StoreCurrencies provides a mock function with given fields: opts
func (_m *IStorage) StoreCurrencies(opts ...repos.Option) repo_store_currencies.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoreCurrencies")
	}

	var r0 repo_store_currencies.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_store_currencies.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_store_currencies.Querier)
		}
	}

	return r0
}

// IStorage_StoreCurrencies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreCurrencies'
type IStorage_StoreCurrencies_Call struct {
	*mock.Call
}

// StoreCurrencies is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) StoreCurrencies(opts ...interface{}) *IStorage_StoreCurrencies_Call {
	return &IStorage_StoreCurrencies_Call{Call: _e.mock.On("StoreCurrencies",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_StoreCurrencies_Call) Run(run func(opts ...repos.Option)) *IStorage_StoreCurrencies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_StoreCurrencies_Call) Return(_a0 repo_store_currencies.Querier) *IStorage_StoreCurrencies_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_StoreCurrencies_Call) RunAndReturn(run func(...repos.Option) repo_store_currencies.Querier) *IStorage_StoreCurrencies_Call {
	_c.Call.Return(run)
	return _c
}

// StoreSecrets provides a mock function with given fields: opts
func (_m *IStorage) StoreSecrets(opts ...repos.Option) repo_store_secrets.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoreSecrets")
	}

	var r0 repo_store_secrets.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_store_secrets.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_store_secrets.Querier)
		}
	}

	return r0
}

// IStorage_StoreSecrets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreSecrets'
type IStorage_StoreSecrets_Call struct {
	*mock.Call
}

// StoreSecrets is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) StoreSecrets(opts ...interface{}) *IStorage_StoreSecrets_Call {
	return &IStorage_StoreSecrets_Call{Call: _e.mock.On("StoreSecrets",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_StoreSecrets_Call) Run(run func(opts ...repos.Option)) *IStorage_StoreSecrets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_StoreSecrets_Call) Return(_a0 repo_store_secrets.Querier) *IStorage_StoreSecrets_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_StoreSecrets_Call) RunAndReturn(run func(...repos.Option) repo_store_secrets.Querier) *IStorage_StoreSecrets_Call {
	_c.Call.Return(run)
	return _c
}

// StoreWebhooks provides a mock function with given fields: opts
func (_m *IStorage) StoreWebhooks(opts ...repos.Option) repo_store_webhooks.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoreWebhooks")
	}

	var r0 repo_store_webhooks.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_store_webhooks.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_store_webhooks.Querier)
		}
	}

	return r0
}

// IStorage_StoreWebhooks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreWebhooks'
type IStorage_StoreWebhooks_Call struct {
	*mock.Call
}

// StoreWebhooks is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) StoreWebhooks(opts ...interface{}) *IStorage_StoreWebhooks_Call {
	return &IStorage_StoreWebhooks_Call{Call: _e.mock.On("StoreWebhooks",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_StoreWebhooks_Call) Run(run func(opts ...repos.Option)) *IStorage_StoreWebhooks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_StoreWebhooks_Call) Return(_a0 repo_store_webhooks.Querier) *IStorage_StoreWebhooks_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_StoreWebhooks_Call) RunAndReturn(run func(...repos.Option) repo_store_webhooks.Querier) *IStorage_StoreWebhooks_Call {
	_c.Call.Return(run)
	return _c
}

// StoreWhitelist provides a mock function with given fields: opts
func (_m *IStorage) StoreWhitelist(opts ...repos.Option) repo_store_whitelist.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StoreWhitelist")
	}

	var r0 repo_store_whitelist.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_store_whitelist.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_store_whitelist.Querier)
		}
	}

	return r0
}

// IStorage_StoreWhitelist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreWhitelist'
type IStorage_StoreWhitelist_Call struct {
	*mock.Call
}

// StoreWhitelist is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) StoreWhitelist(opts ...interface{}) *IStorage_StoreWhitelist_Call {
	return &IStorage_StoreWhitelist_Call{Call: _e.mock.On("StoreWhitelist",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_StoreWhitelist_Call) Run(run func(opts ...repos.Option)) *IStorage_StoreWhitelist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_StoreWhitelist_Call) Return(_a0 repo_store_whitelist.Querier) *IStorage_StoreWhitelist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_StoreWhitelist_Call) RunAndReturn(run func(...repos.Option) repo_store_whitelist.Querier) *IStorage_StoreWhitelist_Call {
	_c.Call.Return(run)
	return _c
}

// Stores provides a mock function with given fields: opts
func (_m *IStorage) Stores(opts ...repos.Option) repo_stores.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Stores")
	}

	var r0 repo_stores.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_stores.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_stores.Querier)
		}
	}

	return r0
}

// IStorage_Stores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stores'
type IStorage_Stores_Call struct {
	*mock.Call
}

// Stores is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Stores(opts ...interface{}) *IStorage_Stores_Call {
	return &IStorage_Stores_Call{Call: _e.mock.On("Stores",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Stores_Call) Run(run func(opts ...repos.Option)) *IStorage_Stores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Stores_Call) Return(_a0 repo_stores.Querier) *IStorage_Stores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Stores_Call) RunAndReturn(run func(...repos.Option) repo_stores.Querier) *IStorage_Stores_Call {
	_c.Call.Return(run)
	return _c
}

// Transactions provides a mock function with given fields: opts
func (_m *IStorage) Transactions(opts ...repos.Option) repo_transactions.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Transactions")
	}

	var r0 repo_transactions.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_transactions.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_transactions.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_Transactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transactions'
type IStorage_Transactions_Call struct {
	*mock.Call
}

// Transactions is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Transactions(opts ...interface{}) *IStorage_Transactions_Call {
	return &IStorage_Transactions_Call{Call: _e.mock.On("Transactions",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Transactions_Call) Run(run func(opts ...repos.Option)) *IStorage_Transactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Transactions_Call) Return(_a0 repo_transactions.ICustomQuerier) *IStorage_Transactions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Transactions_Call) RunAndReturn(run func(...repos.Option) repo_transactions.ICustomQuerier) *IStorage_Transactions_Call {
	_c.Call.Return(run)
	return _c
}

// TransferTransactions provides a mock function with given fields: opts
func (_m *IStorage) TransferTransactions(opts ...repos.Option) repo_transfer_transactions.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TransferTransactions")
	}

	var r0 repo_transfer_transactions.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_transfer_transactions.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_transfer_transactions.Querier)
		}
	}

	return r0
}

// IStorage_TransferTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferTransactions'
type IStorage_TransferTransactions_Call struct {
	*mock.Call
}

// TransferTransactions is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) TransferTransactions(opts ...interface{}) *IStorage_TransferTransactions_Call {
	return &IStorage_TransferTransactions_Call{Call: _e.mock.On("TransferTransactions",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_TransferTransactions_Call) Run(run func(opts ...repos.Option)) *IStorage_TransferTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_TransferTransactions_Call) Return(_a0 repo_transfer_transactions.Querier) *IStorage_TransferTransactions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_TransferTransactions_Call) RunAndReturn(run func(...repos.Option) repo_transfer_transactions.Querier) *IStorage_TransferTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// Transfers provides a mock function with given fields: opts
func (_m *IStorage) Transfers(opts ...repos.Option) repo_transfers.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Transfers")
	}

	var r0 repo_transfers.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_transfers.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_transfers.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_Transfers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Transfers'
type IStorage_Transfers_Call struct {
	*mock.Call
}

// Transfers is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Transfers(opts ...interface{}) *IStorage_Transfers_Call {
	return &IStorage_Transfers_Call{Call: _e.mock.On("Transfers",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Transfers_Call) Run(run func(opts ...repos.Option)) *IStorage_Transfers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Transfers_Call) Return(_a0 repo_transfers.ICustomQuerier) *IStorage_Transfers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Transfers_Call) RunAndReturn(run func(...repos.Option) repo_transfers.ICustomQuerier) *IStorage_Transfers_Call {
	_c.Call.Return(run)
	return _c
}

// TronWalletBalanceStatistics provides a mock function with given fields: opts
func (_m *IStorage) TronWalletBalanceStatistics(opts ...repos.Option) repo_tron_wallet_balance_statistics.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TronWalletBalanceStatistics")
	}

	var r0 repo_tron_wallet_balance_statistics.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_tron_wallet_balance_statistics.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_tron_wallet_balance_statistics.Querier)
		}
	}

	return r0
}

// IStorage_TronWalletBalanceStatistics_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TronWalletBalanceStatistics'
type IStorage_TronWalletBalanceStatistics_Call struct {
	*mock.Call
}

// TronWalletBalanceStatistics is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) TronWalletBalanceStatistics(opts ...interface{}) *IStorage_TronWalletBalanceStatistics_Call {
	return &IStorage_TronWalletBalanceStatistics_Call{Call: _e.mock.On("TronWalletBalanceStatistics",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_TronWalletBalanceStatistics_Call) Run(run func(opts ...repos.Option)) *IStorage_TronWalletBalanceStatistics_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_TronWalletBalanceStatistics_Call) Return(_a0 repo_tron_wallet_balance_statistics.Querier) *IStorage_TronWalletBalanceStatistics_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_TronWalletBalanceStatistics_Call) RunAndReturn(run func(...repos.Option) repo_tron_wallet_balance_statistics.Querier) *IStorage_TronWalletBalanceStatistics_Call {
	_c.Call.Return(run)
	return _c
}

// UnconfirmedTransactions provides a mock function with given fields: opts
func (_m *IStorage) UnconfirmedTransactions(opts ...repos.Option) repo_unconfirmed_transactions.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnconfirmedTransactions")
	}

	var r0 repo_unconfirmed_transactions.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_unconfirmed_transactions.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_unconfirmed_transactions.Querier)
		}
	}

	return r0
}

// IStorage_UnconfirmedTransactions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnconfirmedTransactions'
type IStorage_UnconfirmedTransactions_Call struct {
	*mock.Call
}

// UnconfirmedTransactions is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) UnconfirmedTransactions(opts ...interface{}) *IStorage_UnconfirmedTransactions_Call {
	return &IStorage_UnconfirmedTransactions_Call{Call: _e.mock.On("UnconfirmedTransactions",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_UnconfirmedTransactions_Call) Run(run func(opts ...repos.Option)) *IStorage_UnconfirmedTransactions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_UnconfirmedTransactions_Call) Return(_a0 repo_unconfirmed_transactions.Querier) *IStorage_UnconfirmedTransactions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_UnconfirmedTransactions_Call) RunAndReturn(run func(...repos.Option) repo_unconfirmed_transactions.Querier) *IStorage_UnconfirmedTransactions_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateBalanceQueue provides a mock function with given fields: opts
func (_m *IStorage) UpdateBalanceQueue(opts ...repos.Option) repo_update_balance_queue.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBalanceQueue")
	}

	var r0 repo_update_balance_queue.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_update_balance_queue.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_update_balance_queue.Querier)
		}
	}

	return r0
}

// IStorage_UpdateBalanceQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateBalanceQueue'
type IStorage_UpdateBalanceQueue_Call struct {
	*mock.Call
}

// UpdateBalanceQueue is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) UpdateBalanceQueue(opts ...interface{}) *IStorage_UpdateBalanceQueue_Call {
	return &IStorage_UpdateBalanceQueue_Call{Call: _e.mock.On("UpdateBalanceQueue",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_UpdateBalanceQueue_Call) Run(run func(opts ...repos.Option)) *IStorage_UpdateBalanceQueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_UpdateBalanceQueue_Call) Return(_a0 repo_update_balance_queue.Querier) *IStorage_UpdateBalanceQueue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_UpdateBalanceQueue_Call) RunAndReturn(run func(...repos.Option) repo_update_balance_queue.Querier) *IStorage_UpdateBalanceQueue_Call {
	_c.Call.Return(run)
	return _c
}

// UserExchangePairs provides a mock function with given fields: opts
func (_m *IStorage) UserExchangePairs(opts ...repos.Option) repo_user_exchange_pairs.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserExchangePairs")
	}

	var r0 repo_user_exchange_pairs.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_user_exchange_pairs.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_user_exchange_pairs.Querier)
		}
	}

	return r0
}

// IStorage_UserExchangePairs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserExchangePairs'
type IStorage_UserExchangePairs_Call struct {
	*mock.Call
}

// UserExchangePairs is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) UserExchangePairs(opts ...interface{}) *IStorage_UserExchangePairs_Call {
	return &IStorage_UserExchangePairs_Call{Call: _e.mock.On("UserExchangePairs",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_UserExchangePairs_Call) Run(run func(opts ...repos.Option)) *IStorage_UserExchangePairs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_UserExchangePairs_Call) Return(_a0 repo_user_exchange_pairs.Querier) *IStorage_UserExchangePairs_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_UserExchangePairs_Call) RunAndReturn(run func(...repos.Option) repo_user_exchange_pairs.Querier) *IStorage_UserExchangePairs_Call {
	_c.Call.Return(run)
	return _c
}

// UserExchanges provides a mock function with given fields: opts
func (_m *IStorage) UserExchanges(opts ...repos.Option) repo_user_exchanges.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserExchanges")
	}

	var r0 repo_user_exchanges.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_user_exchanges.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_user_exchanges.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_UserExchanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserExchanges'
type IStorage_UserExchanges_Call struct {
	*mock.Call
}

// UserExchanges is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) UserExchanges(opts ...interface{}) *IStorage_UserExchanges_Call {
	return &IStorage_UserExchanges_Call{Call: _e.mock.On("UserExchanges",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_UserExchanges_Call) Run(run func(opts ...repos.Option)) *IStorage_UserExchanges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_UserExchanges_Call) Return(_a0 repo_user_exchanges.ICustomQuerier) *IStorage_UserExchanges_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_UserExchanges_Call) RunAndReturn(run func(...repos.Option) repo_user_exchanges.ICustomQuerier) *IStorage_UserExchanges_Call {
	_c.Call.Return(run)
	return _c
}

// UserNotifications provides a mock function with given fields: opts
func (_m *IStorage) UserNotifications(opts ...repos.Option) repo_user_notifications.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserNotifications")
	}

	var r0 repo_user_notifications.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_user_notifications.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_user_notifications.Querier)
		}
	}

	return r0
}

// IStorage_UserNotifications_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserNotifications'
type IStorage_UserNotifications_Call struct {
	*mock.Call
}

// UserNotifications is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) UserNotifications(opts ...interface{}) *IStorage_UserNotifications_Call {
	return &IStorage_UserNotifications_Call{Call: _e.mock.On("UserNotifications",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_UserNotifications_Call) Run(run func(opts ...repos.Option)) *IStorage_UserNotifications_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_UserNotifications_Call) Return(_a0 repo_user_notifications.Querier) *IStorage_UserNotifications_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_UserNotifications_Call) RunAndReturn(run func(...repos.Option) repo_user_notifications.Querier) *IStorage_UserNotifications_Call {
	_c.Call.Return(run)
	return _c
}

// UserStores provides a mock function with given fields: opts
func (_m *IStorage) UserStores(opts ...repos.Option) repo_user_stores.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UserStores")
	}

	var r0 repo_user_stores.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_user_stores.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_user_stores.Querier)
		}
	}

	return r0
}

// IStorage_UserStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UserStores'
type IStorage_UserStores_Call struct {
	*mock.Call
}

// UserStores is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) UserStores(opts ...interface{}) *IStorage_UserStores_Call {
	return &IStorage_UserStores_Call{Call: _e.mock.On("UserStores",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_UserStores_Call) Run(run func(opts ...repos.Option)) *IStorage_UserStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_UserStores_Call) Return(_a0 repo_user_stores.Querier) *IStorage_UserStores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_UserStores_Call) RunAndReturn(run func(...repos.Option) repo_user_stores.Querier) *IStorage_UserStores_Call {
	_c.Call.Return(run)
	return _c
}

// Users provides a mock function with given fields: opts
func (_m *IStorage) Users(opts ...repos.Option) repo_users.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Users")
	}

	var r0 repo_users.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_users.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_users.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_Users_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Users'
type IStorage_Users_Call struct {
	*mock.Call
}

// Users is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Users(opts ...interface{}) *IStorage_Users_Call {
	return &IStorage_Users_Call{Call: _e.mock.On("Users",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Users_Call) Run(run func(opts ...repos.Option)) *IStorage_Users_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Users_Call) Return(_a0 repo_users.ICustomQuerier) *IStorage_Users_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Users_Call) RunAndReturn(run func(...repos.Option) repo_users.ICustomQuerier) *IStorage_Users_Call {
	_c.Call.Return(run)
	return _c
}

// WalletAddresses provides a mock function with given fields: opts
func (_m *IStorage) WalletAddresses(opts ...repos.Option) repo_wallet_addresses.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WalletAddresses")
	}

	var r0 repo_wallet_addresses.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_wallet_addresses.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_wallet_addresses.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_WalletAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletAddresses'
type IStorage_WalletAddresses_Call struct {
	*mock.Call
}

// WalletAddresses is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) WalletAddresses(opts ...interface{}) *IStorage_WalletAddresses_Call {
	return &IStorage_WalletAddresses_Call{Call: _e.mock.On("WalletAddresses",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_WalletAddresses_Call) Run(run func(opts ...repos.Option)) *IStorage_WalletAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_WalletAddresses_Call) Return(_a0 repo_wallet_addresses.ICustomQuerier) *IStorage_WalletAddresses_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_WalletAddresses_Call) RunAndReturn(run func(...repos.Option) repo_wallet_addresses.ICustomQuerier) *IStorage_WalletAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// WalletAddressesActivityLog provides a mock function with given fields: opts
func (_m *IStorage) WalletAddressesActivityLog(opts ...repos.Option) repo_wallet_addresses_activity_logs.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WalletAddressesActivityLog")
	}

	var r0 repo_wallet_addresses_activity_logs.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_wallet_addresses_activity_logs.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_wallet_addresses_activity_logs.Querier)
		}
	}

	return r0
}

// IStorage_WalletAddressesActivityLog_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WalletAddressesActivityLog'
type IStorage_WalletAddressesActivityLog_Call struct {
	*mock.Call
}

// WalletAddressesActivityLog is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) WalletAddressesActivityLog(opts ...interface{}) *IStorage_WalletAddressesActivityLog_Call {
	return &IStorage_WalletAddressesActivityLog_Call{Call: _e.mock.On("WalletAddressesActivityLog",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_WalletAddressesActivityLog_Call) Run(run func(opts ...repos.Option)) *IStorage_WalletAddressesActivityLog_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_WalletAddressesActivityLog_Call) Return(_a0 repo_wallet_addresses_activity_logs.Querier) *IStorage_WalletAddressesActivityLog_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_WalletAddressesActivityLog_Call) RunAndReturn(run func(...repos.Option) repo_wallet_addresses_activity_logs.Querier) *IStorage_WalletAddressesActivityLog_Call {
	_c.Call.Return(run)
	return _c
}

// Wallets provides a mock function with given fields: opts
func (_m *IStorage) Wallets(opts ...repos.Option) repo_wallets.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Wallets")
	}

	var r0 repo_wallets.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_wallets.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_wallets.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_Wallets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Wallets'
type IStorage_Wallets_Call struct {
	*mock.Call
}

// Wallets is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) Wallets(opts ...interface{}) *IStorage_Wallets_Call {
	return &IStorage_Wallets_Call{Call: _e.mock.On("Wallets",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_Wallets_Call) Run(run func(opts ...repos.Option)) *IStorage_Wallets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_Wallets_Call) Return(_a0 repo_wallets.ICustomQuerier) *IStorage_Wallets_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_Wallets_Call) RunAndReturn(run func(...repos.Option) repo_wallets.ICustomQuerier) *IStorage_Wallets_Call {
	_c.Call.Return(run)
	return _c
}

// WebHookSendHistories provides a mock function with given fields: opts
func (_m *IStorage) WebHookSendHistories(opts ...repos.Option) repo_webhook_send_histories.ICustomQuerier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebHookSendHistories")
	}

	var r0 repo_webhook_send_histories.ICustomQuerier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_webhook_send_histories.ICustomQuerier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_webhook_send_histories.ICustomQuerier)
		}
	}

	return r0
}

// IStorage_WebHookSendHistories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WebHookSendHistories'
type IStorage_WebHookSendHistories_Call struct {
	*mock.Call
}

// WebHookSendHistories is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) WebHookSendHistories(opts ...interface{}) *IStorage_WebHookSendHistories_Call {
	return &IStorage_WebHookSendHistories_Call{Call: _e.mock.On("WebHookSendHistories",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_WebHookSendHistories_Call) Run(run func(opts ...repos.Option)) *IStorage_WebHookSendHistories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_WebHookSendHistories_Call) Return(_a0 repo_webhook_send_histories.ICustomQuerier) *IStorage_WebHookSendHistories_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_WebHookSendHistories_Call) RunAndReturn(run func(...repos.Option) repo_webhook_send_histories.ICustomQuerier) *IStorage_WebHookSendHistories_Call {
	_c.Call.Return(run)
	return _c
}

// WebHookSendQueue provides a mock function with given fields: opts
func (_m *IStorage) WebHookSendQueue(opts ...repos.Option) repo_webhook_send_queue.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WebHookSendQueue")
	}

	var r0 repo_webhook_send_queue.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_webhook_send_queue.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_webhook_send_queue.Querier)
		}
	}

	return r0
}

// IStorage_WebHookSendQueue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WebHookSendQueue'
type IStorage_WebHookSendQueue_Call struct {
	*mock.Call
}

// WebHookSendQueue is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) WebHookSendQueue(opts ...interface{}) *IStorage_WebHookSendQueue_Call {
	return &IStorage_WebHookSendQueue_Call{Call: _e.mock.On("WebHookSendQueue",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_WebHookSendQueue_Call) Run(run func(opts ...repos.Option)) *IStorage_WebHookSendQueue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_WebHookSendQueue_Call) Return(_a0 repo_webhook_send_queue.Querier) *IStorage_WebHookSendQueue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_WebHookSendQueue_Call) RunAndReturn(run func(...repos.Option) repo_webhook_send_queue.Querier) *IStorage_WebHookSendQueue_Call {
	_c.Call.Return(run)
	return _c
}

// WithdrawalWalletAddresses provides a mock function with given fields: opts
func (_m *IStorage) WithdrawalWalletAddresses(opts ...repos.Option) repo_withdrawal_wallet_addresses.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawalWalletAddresses")
	}

	var r0 repo_withdrawal_wallet_addresses.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_withdrawal_wallet_addresses.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_withdrawal_wallet_addresses.Querier)
		}
	}

	return r0
}

// IStorage_WithdrawalWalletAddresses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithdrawalWalletAddresses'
type IStorage_WithdrawalWalletAddresses_Call struct {
	*mock.Call
}

// WithdrawalWalletAddresses is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) WithdrawalWalletAddresses(opts ...interface{}) *IStorage_WithdrawalWalletAddresses_Call {
	return &IStorage_WithdrawalWalletAddresses_Call{Call: _e.mock.On("WithdrawalWalletAddresses",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_WithdrawalWalletAddresses_Call) Run(run func(opts ...repos.Option)) *IStorage_WithdrawalWalletAddresses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_WithdrawalWalletAddresses_Call) Return(_a0 repo_withdrawal_wallet_addresses.Querier) *IStorage_WithdrawalWalletAddresses_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_WithdrawalWalletAddresses_Call) RunAndReturn(run func(...repos.Option) repo_withdrawal_wallet_addresses.Querier) *IStorage_WithdrawalWalletAddresses_Call {
	_c.Call.Return(run)
	return _c
}

// WithdrawalWallets provides a mock function with given fields: opts
func (_m *IStorage) WithdrawalWallets(opts ...repos.Option) repo_withdrawal_wallets.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawalWallets")
	}

	var r0 repo_withdrawal_wallets.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_withdrawal_wallets.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_withdrawal_wallets.Querier)
		}
	}

	return r0
}

// IStorage_WithdrawalWallets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithdrawalWallets'
type IStorage_WithdrawalWallets_Call struct {
	*mock.Call
}

// WithdrawalWallets is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) WithdrawalWallets(opts ...interface{}) *IStorage_WithdrawalWallets_Call {
	return &IStorage_WithdrawalWallets_Call{Call: _e.mock.On("WithdrawalWallets",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_WithdrawalWallets_Call) Run(run func(opts ...repos.Option)) *IStorage_WithdrawalWallets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_WithdrawalWallets_Call) Return(_a0 repo_withdrawal_wallets.Querier) *IStorage_WithdrawalWallets_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_WithdrawalWallets_Call) RunAndReturn(run func(...repos.Option) repo_withdrawal_wallets.Querier) *IStorage_WithdrawalWallets_Call {
	_c.Call.Return(run)
	return _c
}

// WithdrawalsFromProcessing provides a mock function with given fields: opts
func (_m *IStorage) WithdrawalsFromProcessing(opts ...repos.Option) repo_withdrawal_from_processing_wallets.Querier {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WithdrawalsFromProcessing")
	}

	var r0 repo_withdrawal_from_processing_wallets.Querier
	if rf, ok := ret.Get(0).(func(...repos.Option) repo_withdrawal_from_processing_wallets.Querier); ok {
		r0 = rf(opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repo_withdrawal_from_processing_wallets.Querier)
		}
	}

	return r0
}

// IStorage_WithdrawalsFromProcessing_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WithdrawalsFromProcessing'
type IStorage_WithdrawalsFromProcessing_Call struct {
	*mock.Call
}

// WithdrawalsFromProcessing is a helper method to define mock.On call
//   - opts ...repos.Option
func (_e *IStorage_Expecter) WithdrawalsFromProcessing(opts ...interface{}) *IStorage_WithdrawalsFromProcessing_Call {
	return &IStorage_WithdrawalsFromProcessing_Call{Call: _e.mock.On("WithdrawalsFromProcessing",
		append([]interface{}{}, opts...)...)}
}

func (_c *IStorage_WithdrawalsFromProcessing_Call) Run(run func(opts ...repos.Option)) *IStorage_WithdrawalsFromProcessing_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]repos.Option, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(repos.Option)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *IStorage_WithdrawalsFromProcessing_Call) Return(_a0 repo_withdrawal_from_processing_wallets.Querier) *IStorage_WithdrawalsFromProcessing_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *IStorage_WithdrawalsFromProcessing_Call) RunAndReturn(run func(...repos.Option) repo_withdrawal_from_processing_wallets.Querier) *IStorage_WithdrawalsFromProcessing_Call {
	_c.Call.Return(run)
	return _c
}

// NewIStorage creates a new instance of IStorage. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIStorage(t interface {
	mock.TestingT
	Cleanup(func())
}) *IStorage {
	mock := &IStorage{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
